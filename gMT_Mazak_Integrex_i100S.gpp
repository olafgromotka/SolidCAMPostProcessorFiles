; Machine           : Mazak_Integrex_i100SBartac_SmoothG
; Type              :  Mill Turn 2s1b_spindle
; SubRoutines       :
; Comp Type         : 
; Customer          : MDI
; Rev 1.0 :11.28.2022 GS : Initial Revision to Customer
; Rev 1.1 :01.06.2023 GS : Change G28 lines from VUW to YXZ
;						 : Moved initial safety line above any axis movement
;						 : Added G91 to G28 line, G90 to follow
;						 : H number match to tool number
;						 : TOOL ID to use A=.01 B=.02 C=.03......
;						 : Added High Speed Machining G61.1/G64 and G05P2/G05P0 logic
;						 : Fixed incorrect tool plane callout when B0
;						 : Changed G901 to M901
;						 : G43.4 D9 hardcode changed to H and tool offset
;						 : Added XYZ home before head index
; Rev 1.2 :01.09.2023 GS : Changed YXZ to XYZ in home string
;						 : Changed all operation types tool change calls to use tool_position for TOOL ID output
; Rev 1.3 :01.09.2023 GS : Changed all milling to RADIAL output
;						 : Enabled DPM for 5x paths
;						 : Moved location of G05 commands to after G01 on start and Before G64 on terminate.
;						 : Changed Modality on Spindle Speed and Feedrate on same tool operations
; Rev 1.4 :01.09.2023 GS : Changed duplicate G05 command in HSM operations
;						 : Fixed Finish Speed issue on turning paths
; Rev 1.5 :01.10.2023 GS : Changed 5x cordiante set from OPOS to HPOS for Bit setting 2 on teh G43.4 on the machine
;						 : Fixed the missing G68 on the initial move when applicable
; Rev 1.6 :01.10.2023 GS : Changed 5x feedrate to IPM Feed
;						 : Enabled G68.2 and G53.1 on tilted plane moves instead of G68
; Rev 1.7 :01.12.2023 GS : Changed order in the G68.2 line from ZXY to XYZ per customer request / Did not change Q parameter
;						 : Removed unnessesary braking commands preceeding G68.2
;						 : Fixed modality issue on Spindle selection Mcode
;						 : Fixed issue with POS sets being set incorrectly for G68.2 on the first rapid move
; Rev 1.8 :01.12.2023 GS : Changed the G68.2 P1 to G68.2 for Euler angles - Removed Q parameter
; Rev 1.9 :01.12.2023 GS : Changed the G68.2 Euler angles output
;						 : Fixed XY and Z order on G68.2 startup
;						 : Fixed modality issue with Y axis on G68.2 startup
; Rev 2.0 :01.19.2023 GS : Fixed I/K values in G68.2 for certain rotation consistancy
;						 : Remvoed X clear move between G68.2 positions
;						 : Fixed XY then Z order
; Rev 2.1 :01.20.2023 GS : Removed X/Y return in @fourth axis per customer request
;						 : Fixed XY/Z order on transformed operations
; Rev 2.2 :01.20.2023 GS : Changed XY/Z order on transformed operations to XYZ on same line
;						 : Removed all H codes
;						 : Fixed commented CB positions on X5 jobs
; Rev 2.3 :02.07.2023 GS : Changed Thru Coolant trigger
;						 : Added G82 for zero peck
;						 : Added R/Q parameter for G83
; Rev 2.4 :02.07.2023 GS : Changed Thru Coolant codes to M51/M163
;						 : Changed Q output format
;						 : Changed Plane for drilling from G18 to G17
; Rev 2.5 :02.08.2023 GS : Mod to M_feed_spin to catch spindle change on floor finish
; Rev 2.6 :02.08.2023 GS : Mod to catch turn drilling operations to properly set B axis value to 0
; Rev 2.7 :02.13.2023 GS : Change G50 to G92
;						 : Add tool breakage output
;						 : Added SUB_Appraoch_Hold and Sub_Retract_Home MCOs
; Rev 2.8 :02.14.2023 GS : Mods to Sub Approach and Sub Retract
;						 : Added Unload Arm MCO
;						 : Added params to Partoff to emulate Sub Approach just before the partoff per customer req
; Rev 2.9 :02.15.2023 GS : Removed Duplicate G92
;						 : Added G55W0 for every operation using Sub Spindle
;						 : Multitude of changes to Par off/transfer operation couplete
;						 : Added EOJ preceeding Part Unload MCO
; Rev 3.0 :02.17.2023 GS : Change Unloader MCO spindle stop codes
;						 : Added G94/G95 code before all drilling operations
;						 : Made Feed not modal for op start
; Rev 3.1 :02.21.2023 GS : Added SUB air blast Codes to Part Transfer MCO's in 2 places
;						 : Added nFeedMode to G-code prep line for restart 
; Rev 3.2 :03.03.2023 GS : Fixed Radial drilling when G68.2 active
;						 : Changed G05 and G69 location to before homing string
; Rev 3.3 :03.03.2023 GS : Removed Q value for Drill point locations
;						 : Cancelled G05P2 if comp is found
;						 : Fixed issue with G82 being output for all cycles
; Rev 3.4 :03.03.2023 GS : Added G94/G95 to Part_cutoff/transfer MCO
; Rev 3.5 :03.06.2023 GS : Added a main spindle orient and sub orient to the cut off and transfer cycle before spindle sync
; Rev 3.6 :03.06.2023 GS : Moved M540 and associated code above the M202 and M901
; Rev 3.7 :03.08.2023 GS : Changed order of b_sah option output for cutoff/transfer
; Rev 3.8 :03.08.2023 GS : Fixed modal spin command from Rev 3.7 change
; Rev 3.9 :03.13.2023 GS : Threading cycle changes per manual
;						 : Removed # from tool breakage callouts
; 						 : Sub Side indexing callouts and G68.2 K value fix for sub side milling.
; Rev 4.0 :03.13.2023 GS : Fixed issue with I value from above change
; Rev 4.1 :03.14.2023 GS : Changed EULER logic and output to use NEXT values
; Rev 4.2 :03.14.2023 GS : Removed Main Spindle Orient on SUB ops per customer
; Rev 4.3 :03.23.2023 GS : Flipped the Z axis when Sub Side drilling with G68 active
;						 : Added B0.0 to the Unloader Sequence
; Rev 4.4 :03.24.2023 GS : Added SYNC to the Sub Approach Hold Variables
;						 : Added in the C0 Orient when milling on the sub
; Rev 4.5 :03.29.2023 GS : Changed Static Sub Side work offset to dynamic
; Rev 4.6 :03.30.2023 GS : Removed double G on Sub Side work offset due to nOffset format
;						 : Added redundant MODE/SPINDLE/G10.9 at TC per customer
; Rev 4.7 :04.03.2023 GS : Changed Extended work offset formatting to G54.1P
; Rev 4.8 :04.11.2023 GS : Added N numbers at start of all ops
; Rev 4.9 :08.07.2023 GS : Added H values to all G43/G43.4
;						 : Added M108/M107 for and aft of G53.1
;						 : Added G0 before all G20
;						 : B90 for Part Unloader MCO
;						 : M163 changed to M9 for coolant off for all
;						 : Resolved intermittent missing home command before tool breakage logic
;						 : Implemented New Transfer Sequence Example
;						 : Addressed G92 S value in CUTOFF ops
;						 : Added Stock_Position_MCO
;						 : Added TRANSFER M2S MCO to address highlighted issue with existing part transfer
;						 : Addressed G96/G97 issue with same tool different ops
; Rev 5.0 :08.08.2023 GS : Removed G64 unless G61.2 is used
;						 : Fixed missing spindle/Coolant off before tool breakage detection
;						 : Removed Tool Change from Stock Position MCO and added Z and Z Feed Vars to it
;						 : Removed G92 if G97 is active
;						 : Added work offset to prep line after G00
; Rev 5.1 :08.10.2023 GS : Moved home lines on first tool
;						 : Removed R1 from G97/G96/G92 lines
;						 : Removed double home position at EOP
;						 : Removed G94 on drill cycles (default)
; Rev 5.2 :08.11.2023 GS : Restored R1 onto G92 lines per customer
; Rev 5.3 :08.21.2023 GS : Added R2 to G96 line for CSS ops when SUB side turning
; Rev 5.4 :09.12.2023 GS : Added G93 support for XC milling.
; Rev 5.5 :09.15.2023 GS : Added G61.1 P support
;						 : Added XYZ home after any multi-axis toolpath
;						 : Combined G43.4 H line with first XYZ line
; Rev 5.6 :09.26.2023 GS : Fixed R value issue in turn drilling
;						 : Added G98/G99 functionality in drill cycle options
; Rev 5.7 :09.27.2023 GS : Added UNLOADER comment
;						 : Created M400 ROTORACK MCO
;						 : Created M207 Main Chuck Close MCO
; Rev 5.8 :10.05.2023 GS : Added G61.1 P code to jobs without TC
;						 : Added M108 to X5 jobs without TC
; Rev 5.9 :10.11.2023 GS : Added routine for sync milling 5x jobs on SUB spindle under C axis control versus U
; Rev 6.0 :10.23.2023 GS : Added SYNC for transformed operations on SUB SPINDLE
; Rev 6.1 :10.23.2023 GS : Resolved missing Z on G43.4 repeat operations
;						 : Resolved missing G90 on transform 4x ops
; Rev 6.2 :10.23.2023 GS : Set U0 before Sync then use real C location after Sync code
; Rev 6.3 :10.24.2023 GS : Updated Tool Breakage macro with G54.1P300 and nworkoffset
; Rev 6.4 :01.05.2024 GS : ADD REDUDENT COOLANT ON AND OFF AT EVERY OPERATION FOR RESTARTS
;						 : FORCE TOOL CHANGE DOES NOT TURN OFF COOLANT OR SEND TOOL HOME INBETWEEN OPS.
;						 : DRILLING ON TILTED PLANE POSTS INCORRECT Z  - PATH 19     HAD TO DISABLE DRILL CYCLE FOR IT WORK
;						 : WRAPPED TOOL PATH USING G68.2 AND INCORRECT IJK WHEN IT SHOULD BE G43.4 (TCPC) - PATH 24
; Rev 6.5 :01.05.2024 GS : Removed G68.2 for wrapped path and added G0BC before G43.4 for startup
; Rev 6.6 :01.23.2024 GS : Addressed issue with sub side drilling with incorrect XY locations.
; Rev 6.7 :01.25.2024 GS : Addressed secondard spindle call line added after M902
; Rev 6.8 :01.30.2024 GS : Added additional logic to the above to avoid redunand spindle code when SUB is used.
;						 : Added additional logic to drill to fix logic when 4axis_none is programmed - Drill Lower Z issue
; Rev 6.9 :02.02.2024 GS : Resolved duplicate spindle code in rapid present under certain circumstances





; ---Things to do-----
;
;#region 01-Variable_Declaration
@init_post

	global integer iTraceMode iTraceCount
	local  integer i
	local string sUsr_Account<<10>>

	sUsr_Account<<1>> = 'Greg Abbass'
	sUsr_Account<<2>> = 'glpay'
	sUsr_Account<<3>> = 'gregs'
	sUsr_Account<<4>> = 'rakins5'
	sUsr_Account<<5>> = 'HarryGlover'
	sUsr_Account<<6>> = ''

	while i lt 7
		i = i + 1
		if user_account eq sUsr_Account<<i>>
			if iTraceCount eq 0
				iTraceCount = iTraceCount + 1
				input 'trace 0 = no ... trace 5 = all:' iTraceMode
				trace"all": iTraceMode
			endif
		endif
	endw
	global numeric  nPos<<5>> nPrevPos<<5>> nPosArc<<4>> nSpindleDir nSpin nSpinLimit 
	global numeric  nSpinType nFeedType nCSSLimitMode nCssOnOff<<2>> nFeedTypeCode<<3>>  n4xFeedDia    
	global numeric  nWorkoffset nActiveSpindle nSpindleCode<<50>> nToolDirectionInStation<<4,3>>
	global numeric  nHomeOffset nFeed nGear<<4>> nGearCode<<50,4>> nOffset nMillMode<<4>>  
	global numeric  oxh oyh ozh ncount
	global numeric  nToolLenthType nToolLengthH

	global string   program_number_f sync_label_f
	global string	tool_position_in_turret_f tool_number_f nWorkoffset_f iDiametercomp_f iDOffset_f nOffset_f
	global string   iMotionMode_f iAbsInc_f iMplane_f nFeedType_f nFeed_f sSystem
	global string   nSpindleDir_f nSpin_f nSpinType_f nCSSLimitMode_f nSpinLimit_f sSpindleDir<<3>> 
	global string   nActiveSpindle_f nPos_f<<5>> nPosArc_f<<4>> 
	global string   cCb cCe cPn cPb cPe sUS_date sUS_time dwell_f sPostRev
	global string   sSpinIndex<<50>> sAxisOrder<<2,3>> sUsr_Account<<7>>
	global string   sHomestrFileBegin<<2>> sHomestrtc<<2>> sHomestrFileEnd<<2>> cHomep<<2>> sHomeline<<2>>
	global string   sPartPath sRealFileName sReplaced sErrorMsg<<50>> ChannelIDFormat_f sDouble
	global string   nToolLenthType_f nToolLengthH_f tool_number_f
    
	global logical  bUseprognum bUseprogname bUseFileName bCompTypeOutput bPostRevOutput bDateTimeOutput
	global logical  bWorkoffsettc bTapFeedPerRev bUseSpindleSelection bUseSpindlMode bDiameterCompOutputD
	global logical  bOutputToolMessage bOutputLocations bOptstpbegin bOptstptc bOptstpend bOutputUserMessages
	global logical  bOutputABSINC bOutputToolList bTlseperation bSimpleOffsets b_tclear	
	global logical  bYaxisExist<<50>> bYaxisTurning<<50>> b1stRotary<<50>> b2ndRotary<<50>> 
	global logical  bTlchg bFirstTC<<4>> bManualTC bInitialMove bFirstMove bFirstLineMove bFirstCut  
	global logical  bInCartesian<<4>> bFourthAxisActive bMco bPlaneRotActive b5XMove b_sah_eoj b_sync_sub b_sync_transform_sub
	global logical  bMultiFile bGppContSync bXaxisDiaCoords<<4>> bCartesian bG43_4Active bHSMActive bTCPActive b_HIGH_speed b_skp_spin
	
	global integer  iArcmode iTurnArcmode iWorkOffsetmode iSplit_ProgName_Num iProgendmode iRotaryFeedType
	global integer  iOperationMessage iNumSeparationLines iNumberStations<<2>>
	global integer  iDiametercomp iDOffset iAbsInc iMotionMode iMplane iDrillMode iDPMCalcMethod
	global integer  iSyncLabel<<4>> iMCOSyncLabel<<4>> iSaveSyncLabel<<4>> iMCOSyncLabel<<4>> iset_submachine

	
	global integer  iPosSetType<<5>> iActiveToolPosition<<2>> iRposControl<<4>>     
	global integer  iCoolantM<<100>> iCoolantON<<30>> iCoolantOFF<<30>>       
	global integer  iStopmode iSyncCode sync_status_s iJobType iHomingmode 
	global integer  iDircode<<50,3>> iMillModeOnOff<<4,2>>    
	global integer  iRotaryBrakeOnOff<<50,2>> iBrake<<50>> iChuckClamp<<2,2>>  
	global integer  iSaveTurretNumber<<4>> iSaveTableNumber<<4>> save_job_machine_type<<4>>
	global integer  iTurretNumber iTableNumber iOrder<<5>> 
	global integer  iSyncDelta iSyncStart iPlaneOutputType iPlaneRotType iRSpindleValue iCur_tool
	


	
	;Solidcam Settings       
	clear_change_after_gen = 1
	ncount = 1
    
	; call @init_cycles          
	call @usr_ip_useroptions  

endp
;# endregion
;inc "gMT_Template_Cycles" ; Include File For Cycles
;#region 02-Post_Options
@usr_ip_useroptions
    
	;--------- Tool Change ---------             
	bOutputToolMessage            	= true         ;True = Outputs Tool Message at Tool Change
	bSimpleOffsets                	= true        ;True = Station#/Tool# False = Station/Letter  
	iNumberStations<<1>>          	= 1            ;Number of stations for Channel 1 Turret 
	iNumberStations<<2>>          	= 12           ;Number of stations for Channel 2 Turret                                  
	;--------- Program Header & End ---------
	bUseprognum                   	= true         ;True = Outputs Program Number
	bUseprogname                  	= true         ;True = Outputs Program Name
	iSplit_ProgName_Num           	= 0            ;Sets if Program Name and Number are on separate lines (0=No, 1=Name->Number, 2=Number->Name)
	bUseFileName                  	= true         ;True = Outputs Gcode file name at beginning of file
	bCompTypeOutput               	= false         ;True = Outputs the Cutter Compensation type as a message (i.e. (COMPENSATION-WEAR) ) 
	bPostRevOutput                	= false         ;True = Outputs the Post Revision as a message (i.e. (REV-0.61) )
	sPostRev                      	= '1.0'        ; Post Rev
	bDateTimeOutput               	= true         ;True = Outputs Date & Time
	bOutputToolList               	= false         ;True = Outputs Tool List
	bTlseperation                 	= true   
	iNumSeparationLines           	= 1
	cPn                           	= 'O'          ;Sets the Character(s) before program number (i.e. 'O', ':', or nothing)           
	cPb                           	= ''          ;Sets the Character(s) used for the beginning of file (i.e %)
	cPe                           	= ''          ;Sets the Character(s) used for the beginning of file (i.e %)           
	cCb                           	= '('          ;Sets the begginning Character(s) for comments
	cCe                           	= ')'          ;Sets the ending Character(s) for comments
	iProgendmode                  	= 1            ;Sets the code for ending a program (1=M30,2=M2)
    
	;--------- Motion (Lines,Arc,Raid, Rotary etc) ---------
	bOutputABSINC					= false        ;Output Abs Inc Codes (i.e. G90/G91) 
	iArcmode     					= 2            ;Sets Arc Output Mode (1=AbsIJK,2=IncIJK,3=R 360AbsIJK,4=R 360IncIJK)
	iTurnArcmode 					= 4            ;Sets Turning Arc Output Mode (1=AbsIJK, 2=IncIJK, 3=R 360AbsIJK, 4=R 360IncIJK)
    
	;sAxisOrder<<ChannelID,Line>> = 'X,Y,Z,4th,5th' 0 = no output 1 = output
	sAxisOrder<<1,1>>				= '1,1,1,1,1,' ;Order of output for First Rapid - Line 1 
	sAxisOrder<<1,2>>				= '0,0,0,0,0,' ;Order of output for First Rapid - Line 2
	sAxisOrder<<1,3>>				= '0,0,0,0,0,' ;Order of output for First Rapid - Line 3
																				    
	sAxisOrder<<2,1>>				= '0,0,1,1,1,' ;Order of output for First Rapid - Line 1
	sAxisOrder<<2,2>>				= '1,1,0,0,0,' ;Order of output for First Rapid - Line 2
	sAxisOrder<<2,3>>				= '0,0,0,0,0,' ;Order of output for First Rapid - Line 3
		
	iRposControl<<1>>				= 0			   ;Rotary Pos Normal (-1=No Rotary,0=SolidCAM Direct,1=Positive,2=Negative,3=Shortest Distance 4= first/second_axis_angle)
	iRposControl<<2>>				= 4			   ;Rotary Pos Cartesian (-1=No Rotary,0=SolidCAM Direct,1=Positive,2=Negative,3=Shortest Distance 4= first/second_axis_angle)
	
	iPosSetType<<1>>				= 3            ;Turning Pos Set - 0= pos 1= hpos 2= mpos 3= opos 4= lpos 5= tpos 6= topos 7= rpos 8= rtpos
	iPosSetType<<2>>				= 3            ;3 Axis Pos Set - 0= pos 1= hpos 2= mpos 3= opos 4= lpos 5= tpos 6= topos 7= rpos 8= rtpos
	iPosSetType<<3>>				= 1            ;Cartesian Pos Set - 0= pos 1= hpos 2= mpos 3= opos 4= lpos 5= tpos 6= topos 7= rpos 8= rtpos
	iPosSetType<<4>>				= 4            ;5 Axis (Plane Rotation)- 0= pos 1= hpos 2= mpos 3= opos 4= lpos 5= tpos 6= topos 7= rpos 8= rtpos
	iPosSetType<<5>>				= 1            ;Sim5Ax Pos Set - 0= pos 1= hpos 2= mpos 3= opos 4= lpos 5= tpos 6= topos 7= rpos 8= rtpos

	;--------- Cutter Compensation ---------
	bDiameterCompOutputD           	= true         ;Outputs D number when turning on Cutter Compensation (i.e. G41 D1)
    
	;--------- Optional Stops (M01) ---------
	bOptstpbegin                   	= false        ;True = Outputs Optional Stop at beginning of program
	bOptstptc                      	= true         ;True = Outputs Optional Stop between Tool Changes
	bOptstpend                     	= false        ;True = Outputs Optional Stop at end of program

	;--------- Work Offset ---------
	iWorkOffsetmode      			= 1                     ;Sets the Mode used for Work Offset (0=OFF, 1=G54, 2=E1, 3=G54.1 P1)
	nWorkoffset_f        			= '<G>2/2.0(p)< >'      ;Sets formatting output for workoffset   
	bWorkoffsettc        			= false                  ;True = Forces output of Work Offset at each Tool Change
	nHomeOffset          			= 53                    ;Machine Home Offset Value 
                
	;--------- Plane Rotations --------- 
	iPlaneOutputType					= 1 			;0 = Off, 1 = Fanuc, 2 = Siemens, 3 = Heidenhain
	iPlaneRotType						= 2				;1 = Euler, 2 = Roll-Pitch-Yaw, 3 = Vector
	
	;--------- Feeds and Speeds ---------
	nCSSLimitMode                  	= 92           ;Sets G/M code for "Constant Surface Limit"
	nCssOnOff<<1>>                 	= 96           ;Sets G/M code for "Constant Surface Speed On"
	nCssOnOff<<2>>                 	= 97           ;Sets G/M code for "Constant Surface Speed Off"
	nFeedTypeCode<<1>>             	= 94           ;Sets G/M code for "Feed Per Minute"
	nFeedTypeCode<<2>>             	= 95           ;Sets G/M code for "Feed Per Revolution"
	nFeedTypeCode<<3>>             	= 93           ;Sets G/M code for "Inverse Time Feed rate"
	iRotaryFeedType                	= 4       	  	;Sets Rotary feed output (1=Deg/Min, 2=Inch/MM per Min, 3=Calculated Deg/Min 4=InverseFeed)
	iDPMCalcMethod					= 2				;Sets the calculation type for Deg/Min (1= Interpolation based calculation, 2= Arclength based calculation)
	n4xFeedDia                     	= 1.0          ;Sets Feed Diameter from controller (HAAS #102 Lathe, HAAS #34 Mill)
	
	
	;-------------Options per Spindle-----------
	iMillModeOnOff<<1,1>>			= 200			;Main Milling Mode ON
	iMillModeOnOff<<1,2>>			= 202			;Main Milling Mode OFF
	
	iMillModeOnOff<<2,1>>			= 300			;Sub Milling Mode ON
	iMillModeOnOff<<2,2>>      		= 302			;Sub Milling Mode OFF

	;--------- Table & Turret Forward/Reverse/Stop Codes  --------- 
	; Table and drive address is based off VMID Device Numbers 1-19 Tables and 20-50 Turrets/Heads
	
	;Tables
	bUseSpindleSelection           	= true         ;True = Outputs G/M code for "Spindle Selection"(Main/Sub) 
	bUseSpindlMode                 	= true         	;True = Outputs G/M code for "Spindle Mode"(Turn/Mill) 

	;Main Spindle
	nSpindleCode<<1>>				= 901			;Sets G/M code for "Main Spindle Selection"
	iDircode<<1,1>>					= 203           	;Main Spindle CW
	iDircode<<1,2>>					= 204           	;Main Spindle CCW
	iDircode<<1,3>>					= 205				;Main Spindle OFF
	sSpinIndex<<1>>					= ''			;Spindle Index For Pcodes on spin output
	nGearCode<<1,1>>				= 999			;Mcode for Gear 1
	nGearCode<<1,2>>				= 999			;Mcode for Gear 2
	nGearCode<<1,3>>				= 999			;Mcode for Gear 3

	iRotaryBrakeOnOff<<1,1>> 		= 211			;Sets G/M code for Spindle Brake ON
	iRotaryBrakeOnOff<<1,2>>        = 212   		;Sets G/M code for Spindle Brake OFF
	iChuckClamp<<1,1>>              = 207			;Sets G/M code for Chuck Clamp
	iChuckClamp<<1,2>>              = 206			;Sets G/M code for Chuck Un-Clamp
		
	;Sub Spindle 
	nSpindleCode<<2>>				= 902			;Sets G/M code for "Sub Spindle Selection" 
	iDircode<<2,1>>					= 303           ;SUB Spindle CW	
	iDircode<<2,2>>        			= 304           ;SUB Spindle CCW
	iDircode<<2,3>>        			= 305			;SUB Spindle OFF
	sSpinIndex<<2>>					= ''			;Spindle Index For Pcodes on spin output
	nGearCode<<2,1>>				= 999			;Mcode for Gear 1

	
	iRotaryBrakeOnOff<<2,1>> 		= 310			;Sets G/M code for Spindle Brake ON
	iRotaryBrakeOnOff<<2,2>>        = 312			;Sets G/M code for Spindle Brake OFF
	iChuckClamp<<2,1>>              = 307			;Sets G/M code for Chuck Clamp
	iChuckClamp<<2,2>>              = 308			;Sets G/M code for Chuck Un-Clamp
	
	;Upper Turret B Head
	iDircode<<20,1>>				= 3           	;Spindle CW	
	iDircode<<20,2>>        		= 4           	;Spindle CCW
	iDircode<<20,3>>        		= 5				;Spindle OFF
	sSpinIndex<<20>>				= ''			;Spindle Index For Pcodes on spin output
	nGearCode<<20,1>>				= 999			;Mcode for Gear 1
	 
	b1stRotary<<20>>               	= true         	;false= no 1st rotary, true= yes 1st rotary 
	b2ndRotary<<20>>              	= true        	;false= no 2nd rotary, true= yes 2nd rotary 	
	iRotaryBrakeOnOff<<20,1>> 		= 107			;Sets G/M code for B axis Brake ON
	iRotaryBrakeOnOff<<20,2>>       = 108			;Sets G/M code for B axis Brake OFF
	bYaxisExist<<20>>               = true        	;false= no Y axis, true= yes Y axis 
	bYaxisTurning<<20>>             = true       	;false= no Y axis turning, true= yes Y axis turning
	
	;Lower Turret
	iDircode<<21,1>>				= 203           	;Spindle CW	
	iDircode<<21,2>>        		= 204           	;Spindle CCW
	iDircode<<21,3>>        		= 205				;Spindle OFF
	sSpinIndex<<21>>				= ''			;Spindle Index For Pcodes on spin output
	nGearCode<<21,1>>				= 999			;Mcode for Gear 1
	
	b1stRotary<<21>>               	= true         	;false= no 1st rotary, true= yes 1st rotary 
	b2ndRotary<<21>>              	= false        	;false= no 2nd rotary, true= yes 2nd rotary 	
	bYaxisExist<<21>>               = false        	;false= no Y axis, true= yes Y axis 
	bYaxisTurning<<21>>             = false       	;false= no Y axis turning, true= yes Y axis turning

	;--------- Drilling ---------
	bTapFeedPerRev        			= false       ;1.00: True = Feed Per Rev(G99) is output during Tapping Cycles

	;--------- Coolant Settings ---------              
	iCoolantON<<1>>                	= 8              ;Sets Code: Flood_coolant ON         
	iCoolantOFF<<1>>               	= 9              ;Sets Code: Flood_coolant OFF        
	iCoolantON<<2>>                	= 131              ;Sets Code: HP_flood_coolant ON      
	iCoolantOFF<<2>>               	= 9              ;Sets Code: HP_flood_coolant OFF     
	iCoolantON<<3>>                	= 8              ;Sets Code: LP_flood_coolant ON      
	iCoolantOFF<<3>>               	= 9              ;Sets Code: LP_flood_coolant OFF     
	iCoolantON<<4>>                	= 8              ;Sets Code: flood_ival_coolant ON    
	iCoolantOFF<<4>>               	= 9              ;Sets Code: flood_ival_coolant OFF   
	iCoolantON<<5>>                	= 7              ;Sets Code: mist_coolant ON          
	iCoolantOFF<<5>>               	= 9              ;Sets Code: mist_coolant OFF         
	iCoolantON<<6>>                	= 8              ;Sets Code: HP_mist_coolant ON       
	iCoolantOFF<<6>>               	= 9              ;Sets Code: HP_mist_coolant OFF      
	iCoolantON<<7>>                	= 7              ;Sets Code: LP_mist_coolant ON       
	iCoolantOFF<<7>>               	= 9              ;Sets Code: LP_mist_coolant OFF      
	iCoolantON<<8>>                	= 8              ;Sets Code: mist_ival_coolant ON     
	iCoolantOFF<<8>>               	= 9              ;Sets Code: mist_ival_coolant OFF    
	iCoolantON<<9>>                	= 51            ;Sets Code: through_coolant ON       
	iCoolantOFF<<9>>               	= 9            ;Sets Code: through_coolant OFF      
	iCoolantON<<10>>               	= 51              ;Sets Code: HP_through_coolant ON    
	iCoolantOFF<<10>>              	= 9              ;Sets Code: HP_through_coolant OFF   
	iCoolantON<<11>>               	= 51             ;Sets Code: LP_through_coolant ON    
	iCoolantOFF<<11>>              	= 9              ;Sets Code: LP_through_coolant OFF   
	iCoolantON<<12>>               	= 8              ;Sets Code: through_ival_coolant ON  
	iCoolantOFF<<12>>              	= 9              ;Sets Code: through_ival_coolant OFF 
	iCoolantON<<13>>               	= 7              ;Sets Code: air_blast_coolant ON     
	iCoolantOFF<<13>>              	= 9              ;Sets Code: air_blast_coolant OFF    
	iCoolantON<<14>>               	= 8              ;Sets Code: air_through_coolant ON   
	iCoolantOFF<<14>>              	= 9              ;Sets Code: air_through_coolant OFF  
	iCoolantON<<15>>               	= 8              ;Sets Code: minimum_quantity_L ON    
	iCoolantOFF<<15>>              	= 9              ;Sets Code: minimum_quantity_L OFF   
	iCoolantON<<16>>               	= 8              ;Sets Code: mach_flood_coolant ON
	iCoolantOFF<<16>>              	= 9              ;Sets Code: mach_flood_coolant OFF
	iCoolantON<<17>>               	= 8              ;Sets Code: mach_HP_flood_coolant ON
	iCoolantOFF<<17>>              	= 9              ;Sets Code: mach_HP_flood_coolant OFF
	iCoolantON<<18>>               	= 8              ;Sets Code: mach_LP_flood_coolant ON
	iCoolantOFF<<18>>              	= 9              ;Sets Code: mach_LP_flood_coolant OFF
	iCoolantON<<19>>               	= 8              ;Sets Code: mach_flood_ival_coolant ON
	iCoolantOFF<<19>>              	= 9              ;Sets Code: mach_flood_ival_coolant OFF
	iCoolantON<<20>>               	= 8              ;Sets Code: mach_mist_coolant ON
	iCoolantOFF<<20>>              	= 9              ;Sets Code: mach_mist_coolant OFF
	iCoolantON<<21>>               	= 8              ;Sets Code: mach_HP_mist_coolant ON
	iCoolantOFF<<21>>              	= 9              ;Sets Code: mach_HP_mist_coolant OFF
	iCoolantON<<22>>               	= 8              ;Sets Code: mach_LP_mist_coolant ON
	iCoolantOFF<<22>>              	= 9              ;Sets Code: mach_LP_mist_coolant OFF
	iCoolantON<<23>>               	= 8              ;Sets Code: mach_mist_ival_coolant ON
	iCoolantOFF<<23>>              	= 9              ;Sets Code: mach_mist_ival_coolant OFF
	iCoolantON<<24>>               	= 8              ;Sets Code: mach_active_air_coolant ON
	iCoolantOFF<<24>>              	= 9              ;Sets Code: mach_active_air_coolant OFF
	iCoolantON<<25>>               	= 8              ;Sets Code: mach_bed_rinsing_coolant ON
	iCoolantOFF<<25>>              	= 9              ;Sets Code: mach_bed_rinsing_coolant OFF
    
	;--------- Block/Line Numbering ---------
	blknum_exist                   	= false           ; True = Outputs Line Numbers
	blknum                         	= 1              ; Sets Starting Line Number
	blknum_delta                   	= 1              ; Sets the delta for Line Numbers
	blknum_max                     	= 3200000        ; Sets the maximum value for Line Numbers
    
	;--------- Misc. Options ---------
	iOperationMessage             	= 2              ;Controls output of Operation messge (0=off, 1=long style, 2=short style) 
	bOutputLocations              	= false           ;Output Names of Output Locations  
	bOutputUserMessages           	= true           ;true = outputs user messages (message field found in Operation - Misc parameters tab)
    
	;--------- Multiple Turret File Options ---------
	bMultiFile						= false			 ; false = single channel or multi file VMID, true = gpp controlled separate files
	bGppContSync					= false			 ; true = GPP controls delta and start code, false = SynManager controls
	iSyncDelta 						= 10			 ; Sync Code Delta Amount
	iSyncStart						= 100			 ; Sync Code Start #
	;---------          Homing & Zero Returning axis             ---------
	;--------- Instructions and explanation of definition below ---------

	;  Format: [x][integer:][Prepstr :][AxisStr1 ;][AxisStrN]
	;  x       = Putting 'x' as the first character means "Homing Mode" must be set for each line (i.e. 'x2:G00 :Z0 ;3:G00 :X-15.0 ' )
	;  integer = Homing Output Mode (1=G28, 2=G28 G91, 3=G53 Non-Modal, 4=G53 Modal, 5=G30, 6=G30 G91, 7= any string)
	;  PrepStr = Sets the code(s) for the begging of line used for Homing Axis (i.e. 'G00')
	;  AxisStr = Homing Axis Definition (i.e. 'Z0.0', 'H0.0 W0.')
	;  Note: You can define up to 49 "Homing Lines" separated by ";"
	;  Note: Only use ";" if using more then 1 "Homing Line"
	;  Note: Define string as empty '' to ignore Specific Homing Definition
    
	sHomestrFileBegin<<1>>    		= '2:G91 G00 X0.;G91 G00 Y0.;G91 G00 Z0.'          ; Program Channel 1 Begin Homing Definition    
	sHomestrtc<<1>>           		= '2:G91 G00 X0.;G91 G00 Y0.;G91 G00 Z0.'          ; Tool Change Channel 1  Homing Definition
	sHomestrFileEnd<<1>>      		= '2:G91 G00 X0.;G91 G00 Y0.;G91 G00 Z0.'          ; Program Channel 1 End Homing Definition     
	sHomestrFileBegin<<2>>    		= '2:G91 G00 X0.;G91 G00 Y0.;G91 G00 Z0. '          ; Program Channel 2 Begin Homing Definition    
	sHomestrtc<<2>>           		= '2:G91 G00 X0.;G91 G00 Y0.;G91 G00 Z0.'          ; Tool Change Channel 2  Homing Definition
	sHomestrFileEnd<<2>>      		= '2:G91 G00 X0.;G91 G00 Y0.;G91 G00 Z0.'          ; Program Channel 2 End Homing Definition    
    
endp

;#endregion 

;#region 03-Formating
@usr_format
	if inch_system
		sSystem           = '4'			
	else 
		sSystem           = '3'
	endif
	
	;Tool#/Offests
	tool_position_in_turret_f           = '<T>2/2.0(p)<>'
	tool_number_f                       = '<>2/2.0(p)<>'
	nOffset_f                           = '<>2/2.0(p)< >'
	iDOffset_f                  		= '<D>2/3.0(n)< >'
	

	;--------- Gcodes  ---------
	gcode_f                             = '<G>2/3.2(p)< >'    
	iMotionMode_f						= gcode_f
	nFeedType_f							= gcode_f
	nSpinType_f                         = gcode_f
	nCSSLimitMode_f                     = gcode_f
	iDiametercomp_f                     = gcode_f
	iAbsInc_f                           = gcode_f
	iMplane_f						    = gcode_f
	nToolLenthType_f 					= gcode_f
	nToolLenthType 						= 43
   
	;--------- Mcodes  ---------
	mcode_f                             = '<M>2/3.0(n)< >'
	sync_label_f						= '<M>5.0(p)< >'
	nActiveSpindle_f                    = mcode_f
	nSpindleDir_f      					= mcode_f
	;--------- MISC  ---------

	dwell_f                             = '<P>0/1.3z(n)< >'
	ChannelIDFormat_f					= '5.3(p)'
	program_number_f					= 'z4.0(p)'
	nSpinLimit_f                        = '<S>5.0(p)< >'
	nFeed_f								= '<F>5.'+sSystem+'()< >'
	
	
endp

@usr_format_axis
	;SET: Set formatting strings for controlling output of variables
	local string sY 
	
	sDouble 							= '2'
	
	;X-axis
	if job_machine_type eq turning
		nPos_f<<1>> 		  				= '<X>5.'+sSystem+'(*'+sDouble+')< >'
	else
		nPos_f<<1>> 		  				= '<X>5.'+sSystem+'()< >'
	endif
	
	;Y-axis
	if bInCartesian<<ChannelID>>
		sY = 'C'
	else
		sY = 'Y'
	endif
	
	nPos_f<<2>>       					= '<'+sY+'>5.'+sSystem+'()< >'

	;Z-axis
	nPos_f<<3>> 		  				= '<Z>5.'+sSystem+'()< >'
	
	;First Rotary
	if submachine_ID eq 1
		nPos_f<<4>> 		 			 	= '<C>5.3()< >'
	else
		if b_sync_sub or b_sync_transform_sub
			nPos_f<<4>> 		 			 	= '<C>5.3()< >'
		else
			nPos_f<<4>> 		 			 	= '<U>5.3()< >'
		endif
	endif
	
	;Second Rotary
	nPos_f<<5>> 		  				= '<B>5.3()< >'
	
	;Arcs
	nPosArc_f<<1>>						= '<I>5.'+sSystem+'()< >'
	nPosArc_f<<2>>						= '<J>5.'+sSystem+'()< >'
	nPosArc_f<<3>>						= '<K>5.'+sSystem+'()< >'
	nPosArc_f<<4>>						= '<R>5.'+sSystem+'()< >'
endp

;#endregion

;#region 04-Output_Procedures

@start_of_file ;Program Start Sequence
    
	if bOutputLocations
		{'Start Of File!!!!'}
		{nb}
	endif
	
	
	call @usr_format
	call @usr_init_gmstates
	call @usr_DeleteFileExtension

	if bMultiFile
		;Channel 1
		call @usr_BuildFileStructure((1))
		
		call @usr_sof_character
		call @usr_sof_progname
	
		if bCompTypeOutput
			{nb,cCb'COMPENSATION-WEAR'cCe}
		endif
		if bPostRevOutput
			{nb,cCb,'Post Rev:',sPostRev,cCe}
		endif
		if bDateTimeOutput
			call @usr_US_date
			call @usr_US_time
			{nb,cCb,sUS_date'-'sUS_time,cCe}
		endif 
		
		;Channel 2
		call @usr_BuildFileStructure((2))
		
		call @usr_sof_character
		call @usr_sof_progname
		
		if bDateTimeOutput
			call @usr_US_date
			call @usr_US_time
			{nb,cCb,sUS_date'-'sUS_time,cCe}
		endif 
	else
		if ChannelID eq 0
			ChannelID = 1
		endif
		if ChannelID eq 1			
			call @usr_sof_character
			call @usr_sof_progname
			
			if bCompTypeOutput
				{nb,cCb'COMPENSATION-WEAR'cCe}
			endif
			if bPostRevOutput
				{nb,cCb,'Post Rev:',sPostRev,cCe}
			endif
			if bDateTimeOutput
				call @usr_US_date
				call @usr_US_time
				{nb,cCb,sUS_date'-'sUS_time,cCe}
			endif 				
		elseif ChannelID eq 2	
			call @usr_sof_character
			call @usr_sof_progname
			
			if bDateTimeOutput
				call @usr_US_date
				call @usr_US_time
				{nb,cCb,sUS_date'-'sUS_time,cCe}
			endif 		
		endif
	endif


endp

@start_program ;Beginning of program (Before any tool changes)

	if bOutputLocations
		{nb,'Start Program!!!!'}
	endif 
	if bOptstpbegin
		call @usr_optionalstop
	endif    

	nActiveSpindle = nSpindleCode<<1>>

	if ChannelID eq 1
		{nb, 'G109 L1'}
		{nb, [nActiveSpindle]}
		{nb,'G92 S3000 R1'}
		{nb,'G92 S3000 R2'}
	endif

	if ChannelID eq 2
		{nb, 'G109 L2'}
		{nb, nActiveSpindle}
		{nb,'G92 S3000 R1'}
		{nb,'G92 S3000 R2'}
	endif 
	change(iset_submachine) = true 
endp


@start_of_job ;Operation Start Sequence
	; Handle what happens at start of operation(job)
	; If using Subs we do not make tool change in @start_of_job    
	; 1. MachinePlane for current Operation
	if job_machine_type eq turning or job_machine_type eq milling
		iJobType = job_machine_type
	else        
		iJobType = 1 ;Turning Default for MCO
	endif
	
	
	if ChannelID eq 0
		ChannelID = 1
	endif

	if ChannelID eq 1
		if spindle eq 0 
			iRSpindleValue = 1
		else 
			iRSpindleValue = 2
		endif
	elseif ChannelID eq 2
		if spindle eq 0 
			iRSpindleValue = 2
		else 
			iRSpindleValue = 1
		endif
	endif
    
	if bSimpleOffsets
		;if iJobType eq 1
		;nOffset = tool_offset_number
			
		nOffset = tool_position
		;else
		;nOffset = job_h_offset
		;endif
	else
		nOffset = tool_position_in_turret + (tool_position - 1) * iNumberStations<<ChannelID>>
	endif

	nToolLengthH = nOffset
	
	if bOutputLocations
		{nb,'Start Of Job!!!!'}
	endif

	
	call @usr_Get_Turret_Table_number	
	call @usr_GetToolDirectionInStation
	call @usr_format_axis	
	call @usr_home_number

	; Decide what type of tool change
	if bManualTC    
		call @usr_gmstates_tc 
		if bOptstptc
			call @usr_optionalstop
		endif      
		call @usr_manual_tc        
		bManualTC                       = false
		bTlchg                          = false
		bFirstTC<<ChannelID>>           = false
		bInitialMove                    = true
	elseif bTlchg and bFirstTC<<ChannelID>>  
		if bOptstptc
			call @usr_optionalstop
		endif
		{nl}
		call @usr_prep_home_axis ((sHomestrtc<<ChannelID>>))
		{nb,'G90'}
		if iOperationMessage eq 2
			{nl,nb,ncount:'<N>7.0(n)< >', cCb,job_name,cCe}
		endif 
		if x5_job and submachine_ID eq 2 
			{nb,'M513 (CANCEL SYNC)'}
			b_sync_sub = true
		endif
		call @usr_feed_spin((job_machine_type))
		{nb,'G0 ',nWorkoffset,'G20 G40 G80 G90 ',nFeedType,'G98'}  

  
		call @usr_first_tC
		bTlchg                          = false
		bFirstTC<<ChannelID>>           = false
		bInitialMove                    = true
		if ChannelID eq 1
			change(nToolLenthType) = true
		else
			change(nToolLenthType) = false
		endif



		if job_machine_type eq milling
			if b_sync_sub
				{nb 'M200 (MILLING MAIN)'}
			endif 	
			call @usr_MillingMode((1),(1))
		else
			call @usr_MillingMode((0),(1))
		endif

		

		if bUseSpindleSelection
			if change(iset_submachine)
				call @usr_spindle_selection((1)(1))
				iset_submachine = submachine_ID
				change(iset_submachine) = false
			else
				call @usr_spindle_selection((1)(1))
			endif
		endif



		if job_machine_type eq milling
			{nb,'G10.9 X0 (X=RADIUS)'}
		else
			{nb,'G10.9 X1 (X=DIA)'}
		endif
	
	elseif bTlchg        
		call @usr_gmstates_tc
		if b_HIGH_speed
			{nb,'G05 P0'}
			{nb,'G64'}
			b_HIGH_speed = false
		endif 
		if tool_number eq iCur_tool
			{nb,'(FORCED TC)'}
			call @usr_prep_home_axis ((sHomestrtc<<ChannelID>>))
			{nb,'G90'} 
		endif
		if bOptstptc
			call @usr_optionalstop
		endif
		if iOperationMessage eq 2
			{nl,nb,ncount:'<N>7.0(n)< >', cCb,job_name,cCe}
		endif 
		if x5_job and submachine_ID eq 2
			{nb,'M513 (CANCEL SYNC)'}
			b_sync_sub = true
		endif
		if b_sync_transform_sub	
			{nb,'M513 (CANCEL SYNC)'}	
			b_sync_transform_sub = false
		endif
		
		call @usr_feed_spin((job_machine_type))
		{nb,'G0 ',nWorkoffset,'G20 G40 G80 G90 ',nFeedType,'G98'} 
		call @usr_auto_tc
		bTlchg                          = false
		bInitialMove                    = true
		if ChannelID eq 1
			change(nToolLenthType) = true
		else
			change(nToolLenthType) = false
		endif

		if job_machine_type eq milling 	
			call @usr_MillingMode((1),(1))
		else
			call @usr_MillingMode((0),(1))
		endif

		if bUseSpindleSelection
			if change(iset_submachine)
				call @usr_spindle_selection((1)(1))
				iset_submachine = submachine_ID
				change(iset_submachine) = false
			else
				call @usr_spindle_selection((1)(0))
			endif
		endif

		if job_machine_type eq milling
			{nb,'G10.9 X0 (X=RADIUS)'}
		else
			{nb,'G10.9 X1 (X=DIA)'}
		endif

	else
		if iOperationMessage eq 2
			{nl,nb,ncount:'<N>7.0(n)< >', cCb,job_name,cCe}
		endif
		if x5_job and submachine_ID eq 2
			{nb 'M200 (MILLING MAIN)'}
			{nb 'M300 (MILLING SUB)'}
			{nb 'M902 (SECOND SPINDLE)'}
			b_sync_sub = true
		endif
		call @usr_feed_spin((job_machine_type))
	endif

	;if job_machine_type eq milling 	
	;call @usr_MillingMode((1),(0))
	;else
	;call @usr_MillingMode((0),(0))
	;endif

	;if bUseSpindleSelection
	;if change(iset_submachine)
	;call @usr_spindle_selection((1)(1))
	;iset_submachine = submachine_ID
	;change(iset_submachine) = false
	;else
	;call @usr_spindle_selection((1)(0))
	;endif
	;endif

	;if rot_axis_coord eq axis4_cartesian and !bCartesian and rot_axis_type ne axis4_none
	;if job_machine_type eq milling
	;if bXaxisDiaCoords<<ChannelID>>	
	;{nb,'G10.9 X0 (X=RADIUS)'}
	;bXaxisDiaCoords<<ChannelID>>	 = false
	;endif
	;else
		
	;if !bXaxisDiaCoords<<ChannelID>>	
	;{nb,'G10.9 X1 (X=DIA)'}
	;bXaxisDiaCoords<<ChannelID>>	 = true
	;endif

	;endif
	
	
	;call @usr_feed_spin((job_machine_type))
	call @usr_SpindleDir_SpinFormat((1)(job_machine_type)(0)(iTableNumber)(iTurretNumber) )   
	call @usr_coolant  
	
	iActiveToolPosition<<ChannelID>> = tool_position_in_turret
	
	bFirstMove                      = true
	bFirstLineMove                  = true
	bFirstCut                       = true
    
	if bOutputUserMessages and !bMCO
		call @usr_outputUserMessages
	endif

	if submachine_id eq 2
		{nb,nWorkoffset,'W0.'}
		;{nb,'M200'}
		;{nb,'M901'}
		;{nb,'G0C0.'}
	endif
	ncount = ncount + 1
endp

@usr_first_tC ;First Tool

    
	if bOutputLocations
		{nb,'First TC!!!!'}
	endif

	if change(nWorkoffset) 
		{nb, [nWorkoffset]} 
		change(nWorkoffset) = false
	endif
    
	;{nb,'T',tool_number'.01'}
	call @usr_auto_tc
	; if bOutputToolMessage
	;     {cCb,tool_message,cCe}
	; endif
    
      

endp


@usr_auto_tc ;Auto Tool Change
    
	if bOutputLocations
		{nb,'Auto TC!!!!'}
	endif

	if change(nWorkoffset) 
		{nb, [nWorkoffset]} 
		change(nWorkoffset) = false
	endif

	if ChannelID eq 1
		;{nb,'T',tool_number'.01'}
		{nb tool_number:'<T>3/3.0(p)<.>' nOffset:'<>2/2.0(p)< >' next_tool_number:'<T>3.0(p)< >' 'M6' }
	elseif ChannelID eq 2
		{nb tool_number:'<T>3/3.0(p)<.>' nOffset:'<>2/2.0(p)< >' next_tool_number:'<T>3.0(p)< >' 'M6' }
	endif

	if bOutputToolMessage
		if tool_message ne ''
			{cCb,tool_message,cCe}
		endif
	endif

	iCur_tool = tool_number
endp


@usr_manual_tc ;Manual Tool Change
    
	if bOutputLocations
		{nb,'Manual TC!!!!'}
	endif
    
endp


@usr_initial_move ;first move after TC
    
	if bOutputLocations
		{nb,'Initial Move!!!!'}
	endif

	if bWorkoffsettc and iWorkOffsetmode ne 0
		change(nWorkoffset) = true    
	endif

	;{nb, [nWorkoffset]} 

	if change(i_G61_t) 
		{nb,'G61.1P',i_G61_t}
		change(i_G61_t) = false
	endif

	if change(i_G61_m) 
		{nb,'G61.1P',i_G61_m}
		change(i_G61_m)= false
	endif



	call @usr_MachinePlane((1)(1))

	if !b_sah 
		change(nSpinLimit) = true
		if iJobType eq 1
			if spin_unit eq css and change(nSpinLimit)
				{nb, nCSSLimitMode, [nSpinLimit], 'R'iRSpindleValue}
				;else
				;nSpinLimit = 4000
				;change(nSpinLimit) = true
				;{nb, nCSSLimitMode, [nSpinLimit], 'R'iRSpindleValue}
			endif
		endif

		if change(nGear<<ChannelID>>)
			{nb,[nGear<<ChannelID>>:mcode_f]}
		endif 
		change(nSpinType) = true
		change(nSpin) = true
		change(nSpindleDir) = true

		if job_machine_type eq turning or (job_machine_type eq milling and submachine_ID eq 1)
			{nb, [nSpinType], [nSpin], [nSpindleDir]}
		endif

		if iRSpindleValue eq 2 and spin_unit eq css and job_machine_type eq turning
			{'R'iRSpindleValue}
		endif
	else
		change(nSpinType) = false
		change(nSpin) = false
		change(nSpindleDir) = false
	endif
	if job_machine_type eq milling
		if X5_job
			if b_sync_sub
				{nb 'M108 (B AXIS BRAKE OFF)'}
				{nb 'M212 (C AXIS BRAKE OFF)'}
				{nb 'M312 (U AXIS BRAKE OFF)'}
				{nb 'G0 C0'}
				{nb 'G0 U0'}
				{nb 'M511 (SYNC)'}
			else
				call @usr_Rotary_Brake((0),(0))
			endif
			if submachine_ID eq 2
				{nb, nSpinType, nSpin, nSpindleDir}
				b_skp_spin = true
			endif
			change(iMotionMode) = true
			change(nPos<<4>>) = true
			if ChannelID eq 1
				change(nPos<<5>>) = true
			else
				change(nPos<<5>>) = false
			endif
			;if nPos<<5>> eq 0
			{nb [iMotionMode] [nPos<<4>>] [nPos<<5>>]}
			;else
			;{nb '(' [nPos<<4>>] [nPos<<5>>] ')'}
			;change(nPos<<4>>)= false
			;change(nPos<<5>>)= false
			;endif
		elseif !X5_job and rot_axis_type eq axis4_none ;3X job
			;call @usr_Rotary_Brake((0),(0))
			change(iMotionMode) = true
			change(nPos<<4>>) = true
			if ChannelID eq 1
				change(nPos<<5>>) = true
			else
				change(nPos<<5>>) = false
			endif
			if nPos<<5>> eq 0 
				{nb [iMotionMode] [nPos<<4>>] [nPos<<5>>]}
			else
				if submachine_ID eq 1
					{nb '(' [nPos<<4>>] [nPos<<5>>] ')'}
				else
					{nb,'M200'}
					{nb,'M901'}
					{nb,'G0 C0.'}
					{nb,'M300'}
					{nb,'M902'}

						
					if submachine_ID eq 2
						{nb, nSpinType, nSpin, nSpindleDir}
						b_skp_spin = true
						{nb,'G0 U0. ' [nPos<<5>>] }
						{nb 'M511 (SYNC)'}
						b_sync_transform_sub = true
						{nb,'G0 ' [nPos<<4>>:'<C>5.3()< >']  }
					else
						{nb,'G0 ' [nPos<<4>>] [nPos<<5>>] }
					endif
				endif
				;change(nPos<<4>>)= false
				;change(nPos<<5>>)= false
			endif
			;call @usr_Rotary_Brake((1),(1))
			if nPos<<5>> ne 0 and !b_wrap;and nPos<<5>> ne 180 ;and nPos<<5>> ne 90
				call @usr_PlaneRotation((1))
				call @usr_control_pos_set (('rapid'))
				change(npos<<1>>)=true
				change(npos<<2>>)=true
			endif
		else ;4x job c axis job
			;call @usr_Rotary_Brake((0),(0))
			change(iMotionMode) = true
			change(nPos<<4>>) = true
			if ChannelID eq 1
				change(nPos<<5>>) = true
			else
				change(nPos<<5>>) = false
			endif
			if nPos<<5>> eq 0 or b_wrap
				{nb [iMotionMode] [nPos<<4>>] [nPos<<5>>]}
			else
				if submachine_ID eq 1
					{nb '(' [nPos<<4>>] [nPos<<5>>] ')'}
				else
					{nb,'M200'}
					{nb,'M901'}
					{nb,'G0 C0.'}
					{nb,'M300'}
					{nb,'M902'}
					{nb, nSpinType, nSpin, nSpindleDir}
					b_skp_spin = true
					{nb,'G0 ' [nPos<<4>>] [nPos<<5>>] }
					if submachine_ID eq 2
						{nb 'M511 (SYNC)'}
						b_sync_transform_sub = true
					endif
				endif
				;change(nPos<<4>>)= false
				;change(nPos<<5>>)= false
			endif
			if nPos<<5>> ne 0 ;and nPos<<5>> ne 180 and nPos<<5>> ne 90
				if rot_axis_coord eq axis4_cartesian and job_type ne 'drill' and rot_axis_type ne axis4_none
					call @usr_FaceCartesian((1))
				endif
			endif
			;call @usr_Rotary_Brake((0),(1))
			if nPos<<5>> ne 0 and !b_wrap
				call @usr_PlaneRotation((1))
				call @usr_control_pos_set (('rapid'))
				change(npos<<1>>)=true
				change(npos<<2>>)=true
			endif
		endif		
	else
		if ChannelID eq 1
			call @usr_Rotary_Brake((0),(0))
			change(iMotionMode) = true
			if nPos<<5>> gt 9000 ; catch for turn op drilling
				nPos<<5>> = 0
			endif
			change(nPos<<5>>) = true
			{nb [iMotionMode] [nPos<<5>>]}
			call @usr_Rotary_Brake((0),(1))
		else
			change(nPos<<5>>) = false
		endif
	endif

	change(nToolLengthH) = true 
 endp


@usr_first_move ;first move new job no TC
 
	if bOutputLocations
		{nb,'First Move!!!!'} 
	endif

	if change(i_G61_t) 
		{nb,'G61.1P',i_G61_t}
		change(i_G61_t) = false
	endif

	if change(i_G61_m) 
		{nb,'G61.1P',i_G61_m}
		change(i_G61_m)= false
	endif
  
	call @usr_MachinePlane((1)(0))
    
	if spin_unit eq css and iJobType eq 1
		if change(nSpinLimit)
			{nb, nCSSLimitMode, [nSpinLimit], 'R'iRSpindleValue}
		endif
	endif

	if change (nSpin) or change(nSpindleDir) or change(nSpinType) 
		if change(nGear<<ChannelID>>)
			{nb,[nGear<<ChannelID>>:mcode_f]}
		endif 
		{nb, nSpinType, nSpin, nSpindleDir}
		if iRSpindleValue eq 2 and spin_unit eq css and job_machine_type eq turning
			{'R'iRSpindleValue}
		endif
		change(nSpin) = false
	endif
	
	
	if job_machine_type eq milling
		if change(nPos<<5>>)
			call @usr_prep_home_axis ((sHomestrtc<<ChannelID>>))
			{nb,'G90'}
		endif 
		if X5_job
			iBrake<<iTurretNumber>> = 107
			if b_sync_sub
				{nb 'M108 (B AXIS BRAKE OFF)'}
				{nb 'M212 (C AXIS BRAKE OFF)'}
				{nb 'M312 (U AXIS BRAKE OFF)'}
				{nb 'G0 C0'}
				{nb 'G0 U0'}
				{nb 'M511 (SYNC)'}
			else
				call @usr_Rotary_Brake((0),(0))
			endif
			change(iMotionMode) = true
			change(nPos<<4>>) = true
			if ChannelID eq 1
				change(nPos<<5>>) = true
			else
				change(nPos<<5>>) = false
			endif
			;if nPos<<5>> eq 0
			{nb [iMotionMode] [nPos<<4>>] [nPos<<5>>]}
			;else
			;{nb '(' [nPos<<4>>] [nPos<<5>>] ')'}
			;change(nPos<<4>>)= false
			;change(nPos<<5>>)= false
			;endif	
		elseif !X5_job and rot_axis_type eq axis4_none ;3X job
			;call @usr_Rotary_Brake((0),(0))
			change(iMotionMode) = true
			change(nPos<<4>>) = true
			if ChannelID eq 1
				change(nPos<<5>>) = true
			else
				change(nPos<<5>>) = false
			endif
			if nPos<<5>> eq 0
				{nb [iMotionMode] [nPos<<4>>] [nPos<<5>>]}
			else
				if submachine_ID eq 1
					{nb '(' [nPos<<4>>] [nPos<<5>>] ')'}
				else
					{nb,'M200'}
					{nb,'M901'}
					if !b_sync_transform_sub
						{nb,'G0 C0.'}
					endif
					{nb,'M300'}
					{nb,'M902'}
					{nb, nSpinType, nSpin, nSpindleDir}
					{nb,'G0 ' [nPos<<4>>] [nPos<<5>>] }
				endif
				;change(nPos<<4>>)= false
				;change(nPos<<5>>)= false
			endif
			;call @usr_Rotary_Brake((1),(1))
			if nPos<<5>> ne 0 and !b_wrap;and nPos<<5>> ne 180 ;and nPos<<5>> ne 90
				call @usr_PlaneRotation((1))
				call @usr_control_pos_set (('rapid'))
				change(npos<<1>>)=true
				change(npos<<2>>)=true
			endif
		else ;4x job c axis job
			;call @usr_Rotary_Brake((0),(0))
			change(iMotionMode) = true
			change(nPos<<4>>) = true
			if ChannelID eq 1
				change(nPos<<5>>) = true
			else
				change(nPos<<5>>) = false
			endif
			if nPos<<5>> eq 0
				{nb [iMotionMode] [nPos<<4>>] [nPos<<5>>]}
			else
				if submachine_ID eq 1
					{nb '(' [nPos<<4>>] [nPos<<5>>] ')'}
				else
					{nb,'M200'}
					{nb,'M901'}
					if !b_sync_transform_sub
						{nb,'G0 C0.'}
					endif
					{nb,'M300'}
					{nb,'M902'}
					{nb, nSpinType, nSpin, nSpindleDir}
					{nb,'G0 ' [nPos<<4>>] [nPos<<5>>] }
				endif
				;change(nPos<<4>>)= false
				;change(nPos<<5>>)= false
			endif
			if nPos<<5>> ne 0 ;and nPos<<5>> ne 180 and nPos<<5>> ne 90
				if rot_axis_coord eq axis4_cartesian and job_type ne 'drill' and rot_axis_type ne axis4_none
					call @usr_FaceCartesian((1))
				endif
			endif
			;call @usr_Rotary_Brake((0),(1))
			if nPos<<5>> ne 0 and !b_wrap
				call @usr_PlaneRotation((1))
				call @usr_control_pos_set (('rapid'))
				change(npos<<1>>)=true
				change(npos<<2>>)=true
			endif
		endif		
	else
		call @usr_Rotary_Brake((0),(1))
	endif
endp


@usr_first_cut ;first line or arc move
    
	if bOutputLocations
		{nb,'First Cut!!!!'}
	endif
    
    
endp


@usr_first_linear_move ;first line move

	if bOutputLocations
		{nb,'First Linear Move!!!!'}
	endif
    
endp


@usr_line ;linear move
	; Handle output for line movement (G01)
	; Clamp/Unclamp

	local logical b_flm
	
	call @usr_format_axis
	iMotionMode = 1
       
	if bFirstLineMove 
		call @usr_first_linear_move
		bFirstLineMove = false
		b_flm = true
	endif
    
	if bFirstCut
		call @usr_first_cut
		bFirstCut = false
	endif
	

    
	call @usr_control_pos_set (('line'))
	
	call @usr_rpos_calc
	
	call @usr_setfeed

	if b_flm
		change(nFeed) = true
		b_flm = false
	endif

	if change(nFeedtype)
		{nb,[nFeedType]}
		;if job_machine_type eq milling and !b_HIGH_speed
		;{nb,'G61.1'}
		;change(nFeed) = true
		;endif
	endif

	if job_machine_type eq milling and iDiametercomp ne 40 and b_HIGH_speed
		{nb,'G05 P0'}
		b_HIGH_speed = false
	endif

	{nb,[iMotionMode], [iAbsInc], [iMplane],  [nSpin], [nSpindleDir],[iDiametercomp] [nPos<<1>>], [nPos<<2>>], [nPos<<3>>], [nPos<<4>>], [nPos<<5>>], [iDOffset], [nFeed] }
    
	if job_machine_type eq milling and !b_HIGH_speed and iDiametercomp eq 40
		{nb,'G05 P2'}
		b_HIGH_speed = true
	endif
	call @usr_Set_nPrevPos
    
endp


@usr_arc ;Circular move
	; Handle output for arc movement (G02/G03)
	; Clamp/Unclamp
	
	call @usr_format_axis
	
	if arc_direction eq CCW then
		iMotionMode = 3
	else
		iMotionMode = 2
	endif
    
	if bFirstCut
		call @usr_first_cut
		bFirstCut = false
	endif
	
	if rot_axis_coord eq axis4_polar and rot_axis_type ne axis4_none 
		call @usr_PrintErrorMsg((5))
	endif
    
	call @usr_control_pos_set (('arc'))
	call @usr_setfeed 
    
	{nb, [nFeedType], [iMotionMode], [iAbsInc], [iMplane],[iDiametercomp] [nPos<<1>>], [nPos<<2>>], [nPos<<3>>], [nPosArc<<4>>], [nPosArc<<1>>], [nPosArc<<2>>], [nPosArc<<3>>], [iDOffset], [nFeed]}
    
	call @usr_Set_nPrevPos

endp


@usr_rapid ;Rapid Move
	local integer i j bLT 
	local logical bMovingDown bOutputSpindle bFirstRapid bFL
           
	if bInCartesian<<ChannelID>>	
		iMotionMode = 1
		nFeed = 200
	else
		iMotionMode = 0
		change(nFeed) = false
	endif
    
	call @usr_control_pos_set (('rapid'))
	
	call @usr_rpos_calc

	call @usr_format_axis
  
	if bInitialMove
		call @usr_initial_move
		bInitialMove = false
		bFirstMove = false
		bFirstRapid = true
		
	elseif bFirstMove
		call @usr_first_move
		bFirstMove = false
		bFirstRapid = true
	else
		bFirstRapid = false	
	endif
	
	
	;if ChannelID eq 1
	;nToolLengthH_f = '<P1 H>2/3.0(n)< >'
	;else
	nToolLengthH_f = '<H>2/3.0(n)< >'
	;endif

	if b_wrap
		X5_job = true
	endif
    
	if bFirstRapid and !X5_job 
		i=0
		while  i lt 3
			i = i+1			
			call @usr_axis_order((i))
			if i eq 1 ; First Line Code
				change(iMotionMode) = true
				{nb, [iMotionMode], [nToolLenthType],[nToolLengthH], [iAbsInc], [iMplane], [nWorkoffset]}
				j=0
				while j lt 5 
					j = j+1
					if iOrder<<j>> eq 1
						{[nPos<<j>>]}						
					endif
				endw 
				;change(nToolLengthH) = false
				{[nSpin], [nSpindleDir]}
			elseif i eq 2 ; Second Line Code	
				bFL = true		 
				j=0
				while j lt 5 
					j = j+1
					if iOrder<<j>> eq 1
						if change(nPos<<j>>)
							if bFL
								{nb}
								bFL = false
							endif
							{[iMotionMode] [nPos<<j>>]}
						endif
					endif
				endw
			elseif i eq 3 ; Third Line Code  
				bFL = true         
				j=0
				while j lt 5 
					j = j+1
					if iOrder<<j>> eq 1
						if change(nPos<<j>>)
							if bFL
								{nb}
								bFL = false
							endif
							{[iMotionMode] [nPos<<j>>]}
						endif
					endif
				endw	
			endif           
		endw 
	else    
		if X5_job and (!bTCPActive or !bHSMActive) 
			call @usr_TCP ((1))
			change(nPos<<3>>) = true
			;call @usr_HSM ((1))	
		endif 
		; x y z
		change(nToolLengthH) = false
		if b_skp_spin
		   b_skp_spin = false
		   change(nSpin) = false
		   change(nSpindleDir) = false
		endif
		{nb,[iMotionMode], [iAbsInc], [iMplane], [nWorkoffset], [nPos<<1>>], [nPos<<2>>], [nPos<<3>>], [nPos<<4>>], [nPos<<5>>],[nToolLengthH], [nFeed], [nSpin], [nSpindleDir]}
		if b_sah 
			{nb,'G90 '}
			{nb 'M902 (2ND SPINDLE)'}
			{nb 'M302 (SUB SPINDLE TURNING)'}
			{nb 'M358 (SUB AIR BLAST)'}
			{nb 'M200 (MAIN SPINDLE MILLING)'}
			{nb 'G0 C0.   (ORIENT MAIN)'}
			{nb 'M300     (SUB SPINDLE MILLING)'}
			{nb 'G0 U0. (ORIENT SUB)'}
			{nb,'M306 (OPEN SUB CHUCK)  '}
			{nb 'M540 (TRANSFER MODE ON)'}
			;if b_sah_sync
			;{nb 'M302    (SUB SPINDLE TURNING)'}
			;{nb 'M202    (MAIN SPINDLE TURNING)'}
			;{nb 'M901    (MAIN SPINDLE)'}
			;{nb 'M511 (SYNC)'}
			;{nb 'G92 S4000 R1'}
			;{nb 'G97 S1500 M204 R1'}
			;endif
			{nb,'G54'}
			{nb,'G00 W' pt_r_g53_1}
			{nb,'G94'}
			{nb,'G01 W' pt_f_G53_1 , ' F' pt_f_feedrate_1}
			{nb,'M307 (CLOSE SUB CHUCK)'}
			{nb 'M302    (SUB SPINDLE TURNING)'}
			{nb 'M202    (MAIN SPINDLE TURNING)'}
			{nb 'M901    (MAIN SPINDLE)'}
			{nb 'M511    (SYNC SUB WITH MAIN SPINDLE)'}
			if spin_unit eq css
				nSpinLimit = spin_limit
				{nb, nCSSLimitMode, nSpinLimit, 'R'iRSpindleValue}
			endif
			{nb, nSpinType, nSpin, nSpindleDir}
			{nb,'G95'}

			b_sah = false
			b_sah_sync = false
			b_sah_eoj = true
		endif
	endif
    
	if bFirstRapid
		if bMco
			call @usr_coolant_reset
			call @usr_coolant
		endif
		call @usr_coolant_output
	endif

	if rot_axis_coord eq axis4_cartesian and job_type ne 'drill' and rot_axis_type ne axis4_none
		call @usr_FaceCartesian((1))
	endif
    
	call @usr_Set_nPrevPos

	

endp


@end_of_job
	local logical bHome
	
	if bOutputLocations
		{nb,'End Of Job!!!!'}
	endif
	; Handle what happens at end of operation(job)
	;pass info to next job

	if b_sah_eoj
		call @usr_SpindleDir_SpinFormat((0),(job_machine_type),(1),(iTableNumber),(iTurretNumber))
		{nb 'M513 (CANCEL SYNC)'}
		{nb 'M541 (TRANSFER MODE OFF)'}
		{nb 'G55 W0.0'}
		{nb 'G54'}
		;{nb,'G64'}
		b_sah_eoj = false
	endif
	
	call @usr_FaceCartesian((0))

	if b_HIGH_speed
		{nb,'G05 P0'}
		b_HIGH_speed = false
	endif 		
	call @usr_TCP ((0))
	call @usr_PlaneRotation((0))
	if tool_number ne next_job_tool_number or next_submachine_ID ne submachine_ID or next_job_type_name eq 'machine control operation'   
		if next_command ne '@fourth_axis' and !X5_job
			if b_sync_sub
				{nb,'M513 (CANCEL SYNC)'}
				b_sync_sub = false
			endif	
			call @usr_coolant_off
			call @usr_coolant_output
			call @usr_SpindleDir_SpinFormat((0),(job_machine_type),(1),(iTableNumber),(iTurretNumber))
			call @usr_prep_home_axis ((sHomestrtc<<ChannelID>>))
			{nb,'G90'} 
			b_tclear = true
		endif

	else
		call @usr_coolant_off
		call @usr_coolant_output
		if X5_job
			if b_sync_sub
				{nb,'M513 (CANCEL SYNC)'}
				b_sync_sub = false
			endif
			call @usr_prep_home_axis ((sHomestrtc<<ChannelID>>))
			{nb,'G90'}
		endif 
	endif
	
	;if bFourthAxisActive eq false or used_in_transform_4x eq 0		
	if job_machine_type ne next_job_machine_type
		if job_machine_type eq milling
			call @usr_MillingMode((0),(0))
		endif						
	endif
	;call @usr_HSM ((0))

	;else
	;bFourthAxisActive = true
	;endif

	save_job_machine_type<<ChannelID>> = job_machine_type
	change(nFeed) = true
endp


@end_program
                        
	if bOutputLocations
		{nb,'End Program!!!!'}
	endif
	if bOptstpend
		call @usr_optionalstop
	endif

endp

@end_of_file
	; Handle end of file character

	if bOutputLocations
		{nb,'End Of File!!!!'}
	endif
	

	if ChannelID eq 0 ; need for mco_cycle for last operation
		ChannelID = 1
	endif

	if bMultiFile
		{nl '!!close file=!!'}
		
		ChannelID = 1
		{nl '!!open file='sPartPath'' part_name +'_CHANNEL-' ChannelID'.TXT''!!'}
		{nl '!!copy file='sPartPath''+'1Channel!!'}
		
		call @usr_SpindleDir_SpinFormat((1)(job_machine_type)(0)(iTableNumber)(iTurretNumber) )
		call @usr_coolant_off
		call @usr_coolant_output		
		call @usr_prep_home_axis ((sHomestrFileEnd<<ChannelID>>))
		if iProgendmode eq 1
			{nb, 'M30 '}
		elseif iProgendmode eq 2
			{nb, 'M2 '}
		endif
		if cPe ne ''
			{nl,cPe}
		endif
		
		
		
		ChannelID = 2
		;Channel 2
		{nl '!!close file=!!'}
		{nl '!!open file='sPartPath''part_name+'_CHANNEL-'ChannelID'.TXT''!!'}
		{nl '!!copy file='sPartPath''+'2Channel!!'}
		
		call @usr_SpindleDir_SpinFormat((1)(job_machine_type)(0)(iTableNumber)(iTurretNumber) )
		call @usr_coolant_off
		call @usr_coolant_output		
		call @usr_prep_home_axis ((sHomestrFileEnd<<ChannelID>>))
		if iProgendmode eq 1
			{nb, 'M30 '}
		elseif iProgendmode eq 2
			{nb, 'M2 '}
		endif
		if cPe ne ''
			{nl,cPe}
		endif
		
		
		{nl '!!delete file='sPartPath''+'1Channel!!'}
		{nl '!!delete file='sPartPath''+'2Channel!!'}
		
	else

		call @usr_SpindleDir_SpinFormat((1)(job_machine_type)(0)(iTableNumber)(iTurretNumber) )
		call @usr_coolant_off
		call @usr_coolant_output
		;{nb,'G64'}
		if b_sync_transform_sub	or b_sync_sub
			{nb,'M513 (CANCEL SYNC)'}	
			b_sync_transform_sub = false
			b_sync_sub = false
		endif
		if b_tclear
			call @usr_prep_home_axis ((sHomestrFileEnd<<ChannelID>>))
		endif
		;{nb,'G90'}
		if iProgendmode eq 1
			{nb, 'M30 '}
		elseif iProgendmode eq 2
			{nb, 'M2 '}
		endif
		if cPe ne ''
			{nl,cPe}
		endif
	endif
    
    
endp
;#endregion
;------------------------------------------------------------
;#region 05-Solidcam_Procedures
@absolute_mode
	; Handle setting of AbsoluteMode Gcode 
        
	iAbsInc = 90
	if !bOutputABSINC
		change(iAbsInc) = false
	endif
 
endp

@arc
	; SolidCAM call to normal arc movement
	; We do not use this procedure to output code
	; We create our own procedure for this so that we have one arc formatting section
	b5XMove = false 
	call @usr_arc
endp

@arc_5x
	; SolidCAM call to normal arc movement
	; We do not use this procedure to output code
	; We create our own procedure for this so that we have one arc formatting section
	b5XMove = true
	call @usr_arc
endp

@call_proc
	; Handle call to subroutine

endp


@change_ref_point
	; @change_ref_point Not Supported in this template
    
endp

@change_tool
	bTlchg = true    
	if bMco ;mco tc
		call @start_of_job    
	endif
endp

@compensation
	; Handle setting of Diameter Compensation Gcode 
    
	if side eq COMP_LEFT then
		iDiametercomp = 41
		if bDiameterCompOutputD and iJobType ne 1
			change(iDOffset) = true
		else
			change(iDOffset) = false
		endif
	endif
	if side eq COMP_RIGHT then
		iDiametercomp = 42
		if bDiameterCompOutputD and iJobType ne 1
			change(iDOffset) = true
		else
			change(iDOffset) = false
		endif
	endif
	if side eq COMP_OFF then
		iDiametercomp = 40
		change(iDOffset) = false
	endif

endp

@end_loop

endp

@def_tool
	; Handle GPP direct call to to sync @def_tool and @def_turn_tool                                    
	call @usr_def_tool
endp

@def_turn_tool 
	; Handle GPP direct call to to sync @def_tool and @def_turn_tool                                    
	call @usr_def_tool
endp

@end_proc

endp

@feed_spin
	; Handle GPP direct call to "Turning feed spin"
	; We create our own procedure for this so that we may Sync "Milling and Turning"
	if change(spin)
		nSpin= spin
	endif
endp  

@fourth_axis
	if fourth_axis_last eq false
		bFourthAxisActive = true
		if spindle_direction_x eq 1 or spindle_direction_x eq -1
			iMotionMode = 0
			;{nb  iMotionMode:gcode_f tool_start_plane:nPos_f<<1>>}
		elseif spindle_direction_y eq 1 or spindle_direction_y eq -1 ;does it exist?
			iMotionMode = 0
			;{nb iMotionMode:gcode_f tool_start_plane:nPos_f<<2>>}
		endif

	else
		bFourthAxisActive = false
		call @end_of_job
	endif
endp

@home_number
	; Handle setting WorkOffset Gcode
endp

@line
	; Handle GPP direct call to Line Movement (G01)
	; We not use this procedure to output code
	; We create our own procedure for this so that we may...
	;   Sync with @line, @line_5x, @line_4x, @line4x_polar, @line4x_cartesian
	b5XMove = false
	call @usr_line
endp

@line_5x
	; Handle GPP direct call to Line Movement (G01)
	; We not use this procedure to output code
	; We create our own procedure for this so that we may...
	;   Sync with @line, @line_5x, @line_4x, @line4x_polar, @line4x_cartesian
	b5XMove = true
	call @usr_line
endp

@loop

endp

@loop_matrix_info

endp

@m_feed_spin
	; Handle GPP direct call to "Milling feed spin"
	; We create our own procedure for this so that we may Sync "Milling and Turning"
	if change(spin)
		nSpin = spin
		change(nSpin) = true
	endif

endp

@machine_plane
	; Handle setting of MachinePlane Gcode   

endp

@message
	; We don't always use messages directly from SolidCAM
	if iOperationMessage eq 1
		{nb, cCb,message,cCe}
	endif
endp

@mirror
	; @mirror Not Supported in this template
endp

@move_5x
	; Handle GPP direct call to Rapid Move (G00)
	; We not use this procedure to output code
	; We create our own procedure for this so that we may...
	;   Sync with @rapid_move, @move_5x, @move_4x, @move4x_polar, @move4x_cartesian
	b5XMove = true
	call @usr_rapid
endp 

@offset_change
	; Handle setting of Diameter offset
	iDOffset = d_offset
	change(iDOffset) = false
endp

@proc

endp

@rapid_move
	; Handle GPP direct call to Rapid Move (G00)
	; We not use this procedure to output code
	; We create our own procedure for this so that we may...
	;   Sync with @rapid_move, @move_5x, @move_4x, @move4x_polar, @move4x_cartesian
	b5XMove = false
	call @usr_rapid
endp

@relative_mode
	; Handle setting of IncrementalMode Gcode
    
	iAbsInc = 91
	if !bOutputABSINC
		change(iAbsInc) = false
	endif
    
endp

@rotate
	; @rotate Not Supported in this template
endp

@rotate_to_plane

endp

@sync_process
	if bMultiFile
		call @usr_BuildFileStructure((ChannelID))
	endif
	if bGppContSync
		iSyncLabel<<ChannelID>> = sync_label + iSyncStart + ((iSyncDelta-1)*sync_label)
	else
		iSyncLabel<<ChannelID>> = sync_label
	endif
	;if (iSyncLabel<<ChannelID>>-iSaveSyncLabel<<ChannelID>>) ne iSyncDelta and sync_label ne iSyncStart
	;	call @usr_PrintErrorMsg((6))
	;	{nb 'DELTA SYNC IS: '(iSyncLabel<<ChannelID>>-iSaveSyncLabel<<ChannelID>>)}
	;endif
	iMCOSyncLabel<<ChannelID>> = iSyncLabel<<ChannelID>>
	;if number_jobs_in_label ne 0
	{nl}
	{nb iSyncLabel<<ChannelID>>:sync_label_f}
	{nl}
	;endif
	iSaveSyncLabel<<ChannelID>> = iSyncLabel<<ChannelID>>  

endp

@tool_path_info
endp

@turn_change_tool
	bTlchg = true     
	if bMco ;mco tc
		call @start_of_job    
	endif  
endp
;#endregion

;-----usr_option-------

;#region 06-User_Procedures

@usr_arc_plane (logical bRadius)  
    
	if bRadius
		change (nPosArc<<1>>) = false
		change (nPosArc<<2>>) = false
		change (nPosArc<<3>>) = false 
		change (nPosArc<<4>>) = true
	else     
		if arc_plane_m eq XY 
			change (nPosArc<<1>>) = true
			change (nPosArc<<2>>) = true
			change (nPosArc<<3>>) = false 
			change (nPosArc<<4>>) = false         
		elseif arc_plane_m eq ZX 
			change (nPosArc<<1>>) = true
			change (nPosArc<<2>>) = false
			change (nPosArc<<3>>) = true 
			change (nPosArc<<4>>) = false
		elseif arc_plane_m eq YZ
			change (nPosArc<<1>>) = false
			change (nPosArc<<2>>) = true
			change (nPosArc<<3>>) = true
			change (nPosArc<<4>>) = false
		endif
	endif   

endp

@usr_axis_order(integer iA)

	local integer iP iB il
	local string sTemp sO 
	
	sTemp =sAxisOrder<<ChannelID,iA>>
	il = strlen(sTemp)	
	;{nl'sAxisOrder<<ChannelID,iA>>='sAxisOrder<<ChannelID,iA>>}
	while iB lt 5
		iB = iB + 1
		if iB ne 4			
			iP = instr(sTemp,',')
			sO = left(sTemp,iP-1)		
			iOrder<<iB>> = tonum(sO)
			sTemp = substr(sTemp,ip+1,iL)			
		else			
			iOrder<<iB>> = tonum(sTemp)			
		endif	
		;{nl'iOrder<<'iB'>>='iOrder<<iB>>}
	endw

endp

@usr_BuildFileStructure (integer iCurrentChannel)
	{nl '!!close file=!!'}
	{nl '!!open file='sPartPath''+''iCurrentChannel:ChannelIDFormat_f'Channel!!'}
endp

@usr_control_pos_set (string sOutType)
   
	local numeric xtemp ytemp ztemp xcntrtmp ycntrtmp zcntrtmp xcntrtmp_rel ycntrtmp_rel zcntrtmp_rel
	local logical bRadiusOutput
	local integer iPosSet
	
	if job_machine_type eq turning 
		iPosSet = iPosSetType<<1>>	
	elseif x5_job eq true
		iPosSet = iPosSetType<<5>>
	elseif bPlaneRotActive  
		iPosSet = iPosSetType<<4>>
	else
		if rot_axis_type ne axis4_face  ;RADIAL
			iPosSet = iPosSetType<<2>>
		else
			if 	bInCartesian<<ChannelID>>
				iPosSet = iPosSetType<<3>>
			else
				iPosSet = iPosSetType<<2>>
			endif
		endif
	endif

	if (sOutType eq 'rapid' or sOutType eq 'line' or sOutType eq 'arc')
		if iPosSet eq 0
			xtemp = xpos
			ytemp = ypos
			ztemp = zpos
			xcntrtmp = xcenter
			ycntrtmp = ycenter
			zcntrtmp = zcenter
			xcntrtmp_rel = xcenter_rel
			ycntrtmp_rel = ycenter_rel
			zcntrtmp_rel = zcenter_rel
		elseif iPosSet eq 1
			xtemp = xhpos
			ytemp = yhpos
			ztemp = zhpos
			xcntrtmp = xhcenter
			ycntrtmp = yhcenter
			zcntrtmp = zhcenter
			xcntrtmp_rel = xhcenter_rel
			ycntrtmp_rel = yhcenter_rel
			zcntrtmp_rel = zhcenter_rel
		elseif iPosSet eq 2
			xtemp = xmpos
			ytemp = ympos
			ztemp = zmpos
			xcntrtmp = xmcenter
			ycntrtmp = ymcenter
			zcntrtmp = zmcenter
			xcntrtmp_rel = xmcenter_rel
			ycntrtmp_rel = ymcenter_rel
			zcntrtmp_rel = zmcenter_rel
		elseif iPosSet eq 3
			xtemp = xopos
			ytemp = yopos
			ztemp = zopos
			xcntrtmp = xocenter
			ycntrtmp = yocenter
			zcntrtmp = zocenter
			xcntrtmp_rel = xocenter_rel
			ycntrtmp_rel = yocenter_rel
			zcntrtmp_rel = zocenter_rel
		elseif iPosSet eq 4
			xtemp = xlpos
			ytemp = ylpos
			ztemp = zlpos
			xcntrtmp = xlcenter
			ycntrtmp = ylcenter
			zcntrtmp = zlcenter
			xcntrtmp_rel = xlcenter_rel
			ycntrtmp_rel = ylcenter_rel
			zcntrtmp_rel = zlcenter_rel
		elseif iPosSet eq 5
			xtemp = xtpos
			ytemp = ytpos
			ztemp = ztpos
			xcntrtmp = xtcenter
			ycntrtmp = ytcenter
			zcntrtmp = ztcenter
			xcntrtmp_rel = xtcenter_rel
			ycntrtmp_rel = ytcenter_rel
			zcntrtmp_rel = ztcenter_rel
		elseif iPosSet eq 6
			;xtemp = xtopos
			;ytemp = ytopos
			;ztemp = ztopos
			;xcntrtmp = xtocenter
			;ycntrtmp = ytocenter
			;zcntrtmp = ztocenter
			;xcntrtmp_rel = xtcenter_rel
			;ycntrtmp_rel = ytcenter_rel
			;zcntrtmp_rel = ztcenter_rel          
		elseif iPosSet eq 7
			xtemp = xrpos
			ytemp = yrpos
			ztemp = zrpos
			xcntrtmp = xrcenter
			ycntrtmp = yrcenter
			zcntrtmp = zrcenter
			xcntrtmp_rel = xtcenter_rel
			ycntrtmp_rel = ytcenter_rel
			zcntrtmp_rel = ztcenter_rel      
		elseif iPosSet ge 8
			xtemp = xrtpos
			ytemp = yrtpos
			ztemp = zrtpos
			xcntrtmp = xrtcenter
			ycntrtmp = yrtcenter
			zcntrtmp = zrtcenter
			xcntrtmp_rel = xtcenter_rel
			ycntrtmp_rel = ytcenter_rel
			zcntrtmp_rel = ztcenter_rel
		endif 
			   
		;set postion output      
		nPos<<1>> = xtemp
		nPos<<2>> = ytemp
		nPos<<3>> = ztemp
		
		if (!bYaxisExist<<iTurretNumber>> or (iJobType eq 1 and !bYaxisTurning<<iTurretNumber>>)) and !bInCartesian<<ChannelID>>
			change(nPos<<2>>) = false
		endif 
	endif

	;set arc output
	if sOutType eq 'arc'   
		if job_machine_type eq turning 
			if iTurnArcmode eq 1 or (arc_size eq 360 and iTurnArcmode eq 3)
				nPosArc<<1>> = xcntrtmp
				nPosArc<<2>> = ycntrtmp
				nPosArc<<3>> = zcntrtmp
				change (nPosArc<<4>>) = false
				bRadiusOutput = false
			elseif iTurnArcmode eq 2 or (arc_size eq 360 and iTurnArcmode eq 4)
				nPosArc<<1>> = xcntrtmp_rel
				nPosArc<<2>> = ycntrtmp_rel
				nPosArc<<3>> = zcntrtmp_rel
				change (nPosArc<<4>>) = false
				bRadiusOutput = false
			elseif (iTurnArcmode eq 3 or iTurnArcmode eq 4) and arc_size ne 360
				if arc_size >= 180 then
					nPosArc<<4>> = -radius
				else
					nPosArc<<4>> = radius
				endif
				bRadiusOutput = true                               
			endif
		else
			if iArcmode eq 1 or (arc_size eq 360 and iArcmode eq 3)
				nPosArc<<1>> = xcntrtmp
				nPosArc<<2>> = ycntrtmp
				nPosArc<<3>> = zcntrtmp
				bRadiusOutput = false
			elseif iArcmode eq 2 or (arc_size eq 360 and iArcmode eq 4)
				nPosArc<<1>> = xcntrtmp_rel
				nPosArc<<2>> = ycntrtmp_rel
				nPosArc<<3>> = zcntrtmp_rel
				bRadiusOutput = false
			elseif (iArcmode eq 3 or iArcmode eq 4) and arc_size ne 360
				if arc_size >= 180 then
					nPosArc<<4>> = -radius
				else
					nPosArc<<4>> = radius
				endif
				bRadiusOutput = true      
			endif        
		endif
		call @usr_arc_plane ((bRadiusOutput))
	endif

endp

@usr_coolant
	; Handle setting of coolant variable
	if flood_coolant eq 1
		iCoolantM<<1>> = iCoolantON<<1>>
	elseif flood_coolant eq 0 or flood_coolant eq 2
		iCoolantM<<1>> = iCoolantOFF<<1>>
	endif
        
	if HP_flood_coolant eq 1
		iCoolantM<<2>> = iCoolantON<<2>>
	elseif HP_flood_coolant eq 0 or HP_flood_coolant eq 2
		iCoolantM<<2>> = iCoolantOFF<<2>>
	endif
    
	if LP_flood_coolant eq 1
		iCoolantM<<3>> = iCoolantON<<3>>
	elseif LP_flood_coolant eq 0 or LP_flood_coolant eq 2
		iCoolantM<<3>> = iCoolantOFF<<3>>
	endif
    
	if flood_ival_coolant eq 1
		iCoolantM<<4>> = iCoolantON<<4>>
		flood_coolant_val = 0
	elseif flood_ival_coolant eq 0 or flood_ival_coolant eq 2
		iCoolantM<<4>> = iCoolantOFF<<4>>
	endif
    
	if mist_coolant eq 1
		iCoolantM<<5>> = iCoolantON<<5>>
	elseif mist_coolant eq 0 or mist_coolant eq 2
		iCoolantM<<5>> = iCoolantOFF<<5>>
	endif
    
	if HP_mist_coolant eq 1
		iCoolantM<<6>> = iCoolantON<<6>>
	elseif HP_mist_coolant eq 0 or HP_mist_coolant eq 2
		iCoolantM<<6>> = iCoolantOFF<<6>>
	endif
    
	if LP_mist_coolant eq 1
		iCoolantM<<7>> = iCoolantON<<7>>
	elseif LP_mist_coolant eq 0 or LP_mist_coolant eq 2
		iCoolantM<<7>> = iCoolantOFF<<7>>
	endif
    
	if mist_ival_coolant eq 1
		iCoolantM<<8>> = iCoolantON<<8>>
		mist_coolant_val = 0
	elseif mist_ival_coolant eq 0 or mist_ival_coolant eq 2
		iCoolantM<<8>> = iCoolantOFF<<8>>
	endif
    
	if through_coolant eq 1
		iCoolantM<<9>> = iCoolantON<<9>>
	elseif through_coolant eq 0 or through_coolant eq 2
		iCoolantM<<9>> = iCoolantOFF<<9>>
	endif
    
	if HP_through_coolant eq 1
		iCoolantM<<10>> = iCoolantON<<10>>
	elseif HP_through_coolant eq 0 or HP_through_coolant eq 2
		iCoolantM<<10>> = iCoolantOFF<<10>>
	endif
    
	if LP_through_coolant eq 1
		iCoolantM<<11>> = iCoolantON<<11>>
	elseif LP_through_coolant eq 0 or LP_through_coolant eq 2
		iCoolantM<<11>> = iCoolantOFF<<11>>
	endif
    
	if through_ival_coolant eq 1
		iCoolantM<<12>> = iCoolantON<<12>>
		through_coolant_val = 0
	elseif through_ival_coolant eq 0 or through_ival_coolant eq 2
		iCoolantM<<12>> = iCoolantOFF<<12>>
	endif
    
	if air_blast_coolant eq 1
		iCoolantM<<13>> = iCoolantON<<13>>
	elseif air_blast_coolant eq 0 or air_blast_coolant eq 2
		iCoolantM<<13>> = iCoolantOFF<<13>>
	endif
    
	if air_through_coolant eq 1
		iCoolantM<<14>> = iCoolantON<<14>>
	elseif air_through_coolant eq 0 or air_through_coolant eq 2
		iCoolantM<<14>> = iCoolantOFF<<14>>
	endif
    
	if minimum_quantity_L eq 1
		iCoolantM<<15>> = iCoolantON<<15>>
		minimum_quantity_L_val = 0
	elseif minimum_quantity_L eq 0 or minimum_quantity_L eq 2
		iCoolantM<<15>> = iCoolantOFF<<15>>
	endif
    
	if mach_flood_coolant eq 1
		iCoolantM<<16>> = iCoolantON<<16>>
	elseif mach_flood_coolant eq 0 or mach_flood_coolant eq 2
		iCoolantM<<16>> = iCoolantOFF<<16>>
	endif
    
	if mach_HP_flood_coolant eq 1
		iCoolantM<<17>> = iCoolantON<<17>>
	elseif mach_HP_flood_coolant eq 0 or mach_HP_flood_coolant eq 2
		iCoolantM<<17>> = iCoolantOFF<<17>>
	endif
    
	if mach_LP_flood_coolant eq 1
		iCoolantM<<18>> = iCoolantON<<18>>
	elseif mach_LP_flood_coolant eq 0 or mach_LP_flood_coolant eq 2
		iCoolantM<<18>> = iCoolantOFF<<18>>
	endif
    
	if mach_flood_ival_coolant eq 1
		iCoolantM<<19>> = iCoolantON<<19>>
		mach_flood_coolant_val = 0
	elseif mach_flood_ival_coolant eq 0 or mach_flood_ival_coolant eq 2
		iCoolantM<<19>> = iCoolantOFF<<19>>
	endif
    
	if mach_mist_coolant eq 1
		iCoolantM<<20>> = iCoolantON<<20>>
	elseif mach_mist_coolant eq 0 or mach_mist_coolant eq 2
		iCoolantM<<20>> = iCoolantOFF<<20>>
	endif
    
	if mach_HP_mist_coolant eq 1
		iCoolantM<<21>> = iCoolantON<<21>>
	elseif mach_HP_mist_coolant eq 0 or mach_HP_mist_coolant eq 2
		iCoolantM<<21>> = iCoolantOFF<<21>>
	endif
    
	if mach_LP_mist_coolant eq 1
		iCoolantM<<22>> = iCoolantON<<22>>
	elseif mach_LP_mist_coolant eq 0 or mach_LP_mist_coolant eq 2
		iCoolantM<<22>> = iCoolantOFF<<22>>
	endif
    
	if mach_mist_ival_coolant eq 1
		iCoolantM<<23>> = iCoolantON<<23>>
		mach_mist_coolant_val = 0
	elseif mach_mist_ival_coolant eq 0 or mach_mist_ival_coolant eq 2
		iCoolantM<<23>> = iCoolantOFF<<23>>
	endif
    
	if mach_active_air_coolant eq 1
		iCoolantM<<24>> = iCoolantON<<24>>
	elseif mach_active_air_coolant eq 0 or mach_active_air_coolant eq 2
		iCoolantM<<24>> = iCoolantOFF<<24>>
	endif
    
	if mach_bed_rinsing_coolant eq 1
		iCoolantM<<25>> = iCoolantON<<25>>
	elseif mach_bed_rinsing_coolant eq 0 or mach_bed_rinsing_coolant eq 2
		iCoolantM<<25>> = iCoolantOFF<<25>>
	endif
    
endp

@usr_coolant_off
	local integer i
	i = 1
	while i le 25
		iCoolantM<<i>> = iCoolantOFF<<i>> 
		i = i + 1 
	endw 
endp

@usr_coolant_output
	; Handle output of coolant variable
	local integer i e CoolCount<<1000>>
    
	i = 1 
	while i le 25
		;{nb,'i= 'i}
		if change(iCoolantM<<i>>)
			e = iCoolantM<<i>>
			CoolCount<<e>> = CoolCount<<e>> + 1
			if CoolCount<<e>> eq 1
				{nb,[iCoolantM<<i>>:mcode_f]}  
			endif
		endif
		;change(iCoolantM<<i>>) = false
		i = i + 1
	endw
endp

@usr_coolant_reset  
	local integer i
	i = 2
	while i le 25
		change(iCoolantM<<i>>) = false  
		i = i + 1 
	endw 
endp

@usr_def_tool
    
	Local string sToolType
  
	if bOutputToolList
		if ChannelID eq 0
			ChannelID = 1
		endif
		if bSimpleOffsets
			;{nb, cCb,tool_position_in_turret,tool_number,cCe} 
			{nl,tool_number:'<( * TOOL >8.0(p)< >'tool_position_in_turret:'<STATION >z2.0(p)< >'}
			{tool_number:'<OFFSET >z2.0(p)< * >'}    
		else 
			{nl,tool_number:'<( * TOOL >8.0(p)< >'tool_position_in_turret:'<STATION >z2.0(p)< >'}
			{(tool_position_in_turret+(tool_position-1)*iNumberStations<<ChannelID>>):'<OFFSET >z2.0(p)< * >'}
		endif
		if tool_message ne ''
			{upper(tool_message)' '}
		endif
		
		{')'}

		If msg_mill_tool1 ne ''
			{nl,cCb msg_mill_tool1,cCe}
		Endif
		If msg_turn_tool1 ne ''
			{nl,cCb msg_turn_tool1,cCe}
		Endif

		If msg_mill_tool2 ne ''
			{nl,cCb msg_mill_tool2,cCe}
		Endif
		If msg_turn_tool2 ne ''
			{nl,cCb msg_turn_tool2,cCe}
		Endif

		If msg_mill_tool3 ne ''
			{nl,cCb msg_mill_tool3,cCe}
		Endif
		If msg_turn_tool3 ne ''
			{nl,cCb msg_turn_tool3,cCe}
		Endif

		If msg_mill_tool4 ne ''
			{nl,cCb msg_mill_tool4,cCe}
		Endif
		If msg_turn_tool4 ne ''
			{nl,cCb msg_turn_tool4,cCe}
		Endif

		If msg_mill_tool5 ne ''
			{nl,cCb msg_mill_tool5,cCe}
		Endif
		If msg_turn_tool5 ne ''
			{nl,cCb msg_turn_tool5,cCe}
		Endif
		
		msg_mill_tool1 = ''
		msg_turn_tool1 = ''
		msg_mill_tool2 = ''
		msg_turn_tool2 = ''
		msg_mill_tool3 = ''
		msg_turn_tool3 = ''
		msg_mill_tool4 = ''
		msg_turn_tool4 = ''
		msg_mill_tool5 = ''
		msg_turn_tool5 = ''

	endif
	if next_command ne '@def_tool' and next_command ne '@def_turn_tool' and bTlchg eq false
		if bTlseperation and bOutputToolList
			local integer i ii
			i = 0
			if iNumSeparationLines == 0
				ii = 1
			else
				ii = iNumSeparationLines
			endif
			while i < ii
				{nl}
				i = i + 1
			endw
		endif
	endif
    
endp

@usr_DeleteFileExtension
	; remove file extension / locate path for proc file and main g_file
	local integer iSuffixLenghth iGFileLenghth iFullGFileLenghth
	iGFileLenghth = strlen(g_file_name)
	iFullGFileLenghth = strlen(full_g_file_name)
	iFullGFileLenghth = iFullGFileLenghth-iGFileLenghth
	sPartPath = left(full_g_file_name,iFullGFileLenghth)
	iGFileLenghth = iGFileLenghth-4 ; 4 = .TXT
	
	sReplaced=g_file_name
	call @Usr_ReplaceStrings
	sRealFileName = left(sReplaced,iGFileLenghth)
endp

@usr_FaceCartesian(logical bCartesian)
	if bCartesian eq true and !bInCartesian<<ChannelID>>
		gcode = 12.1
		{nb,'G17XC'}
		{nb gcode}
		bInCartesian<<ChannelID>> = true
	elseif !bCartesian and bInCartesian<<ChannelID>> eq true
		gcode = 13.1
		{nb gcode}
		bInCartesian<<ChannelID>> = false
	endif
endp

@usr_feed_spin(integer iType)
	local integer iLocalFeedUnit
	if instr(job_type,'drill') eq 1
		iLocalFeedUnit = feed_status
	else
		iLocalFeedUnit = feed_unit
	endif


	if iType eq 0
		if slave_drive_unit ne 1	

			if iLocalFeedUnit eq 0 or iLocalFeedUnit eq 2
				if (rot_axis_type ne axis4_none or X5_job) and iRotaryFeedType eq 4
					nFeedType = nFeedTypeCode<<3>>
				else
					nFeedType = nFeedTypeCode<<1>>;mm/min in/min
				endif
			else
				nFeedType = nFeedTypeCode<<2>> ;mm/rev in/rev
			endif
		endif		
	elseif iType eq 1	
		if slave_drive_unit ne 1
			if (rot_axis_type ne axis4_none or X5_job) and iRotaryFeedType eq 4
				nFeedType = nFeedTypeCode<<3>>
			elseif iLocalFeedUnit eq 0
				nFeedType = nFeedTypeCode<<1>>;mm/min in/min
			else
				nFeedType = nFeedTypeCode<<2>> ;mm/rev in/rev				
			endif					
		endif		
	endif
	if spin_unit eq css
		nSpinType = nCssOnOff<<1>>
		nSpinLimit = spin_limit
	endif
	if spin_unit eq rpm
		nSpinType = nCssOnOff<<2>>
	endif	
endp  

@usr_Get_Turret_Table_number
	iTurretNumber = get_turret_num(submachine_ID)
	iTableNumber = get_table_num(submachine_ID)	
	
	iSaveTurretNumber<<ChannelID>> = iTurretNumber
	iSaveTableNumber<<ChannelID>> = iTableNumber
	;{nb 'iTurretNumber='iTurretNumber}
	;{nb 'iTableNumber='iTableNumber}
endp

@usr_GetToolDirectionInStation
	local integer iL_Result
	local numeric nL_VectorX nL_VectorY nL_VectorZ

	;Vector depends on the tool station coordinate system from VMID and not from the submachine coordinate system!
	iL_Result = get_tool_dir_in_station(tool_tag,nL_VectorX,nL_VectorY,nL_VectorZ)
	nToolDirectionInStation<<ChannelID,1>> = nL_VectorX
	nToolDirectionInStation<<ChannelID,2>> = nL_VectorY
	nToolDirectionInStation<<ChannelID,3>> = nL_VectorZ
endp

@usr_gmstates_tc
	; set modality for each channel first tool change
	if bFirstTC<<ChannelID>>
		change(nActiveSpindle)  = true
		change(iMplane)         = true     
		nSpinLimit              = -1
	endif
    
	; set modality for every tool change
	if spindle eq 0
		nPos<<1>> = 9999
		nPos<<2>> = 9999
		nPos<<3>> = 9999
		nPos<<4>> = 9999
		nPos<<5>> = 9999
		nPrevPos<<1>> = 9999
		nPrevPos<<2>> = 9999
		nPrevPos<<3>> = 9999
		nPrevPos<<4>> = 9999
		nPrevPos<<5>> = 9999
	elseif spindle eq 1
		nPos<<1>> = 9999
		nPos<<2>> = 9999
		nPos<<3>> = -9999
		nPos<<4>> = 9999
		nPos<<5>> = 9999      
		nPrevPos<<1>> = 9999
		nPrevPos<<2>> = 9999
		nPrevPos<<3>> = -9999
		nPrevPos<<4>> = 9999
		nPrevPos<<5>> = 9999
	endif
    
	nSpin = 0             
	iMotionMode = 9999
	nSpindleDir = 9999
	if bOutputABSINC
		change(iAbsInc) = true
	else
		change(iAbsInc) = false
	endif
	change(iDOffset) = false
    
endp

@usr_home_axis
	; Handle output for homing the X-axis
	local numeric sav_nWorkOffset
	sav_nWorkOffset = nWorkOffset
	if iHomingmode eq 1
		{nb,cHomep'G28 'sHomeline}
	endif
	if iHomingmode eq 2
		{nb,cHomep'G28 '}
		iAbsInc = 91
		change(iAbsInc) = true
		;{[iAbsInc]}
		{ sHomeline}
		iAbsInc = 90
		change(iAbsInc) = true
	endif
	if iHomingmode eq 3 or iHomingmode eq 4
		if iWorkOffsetmode eq 1 or iWorkOffsetmode eq 3
			nWorkOffset = 53       
			{nb,cHomep,[nWorkoffset]}
		endif
		if iWorkOffsetmode eq 2
			nWorkOffset = 0
			{nb,cHomep,[nWorkoffset]}
		endif
		;{[iAbsInc]}
		{ sHomeline}
		nWorkOffset = sav_nWorkOffset
		if iHomingmode eq 3
			change(nWorkOffset) = false
		endif
	endif
	if iHomingmode eq 5
		{nb,cHomep'G30 'sHomeline}
	endif
	if iHomingmode eq 6
		{nb,cHomep'G30 '}
		iAbsInc = 91
		change(iAbsInc) = true
		;{[iAbsInc]}
		{ sHomeline}
		iAbsInc = 90
		change(iAbsInc) = true
	endif
	if iHomingmode eq 7
		{nb, sHomeline}
	endif
endp

@usr_home_number
	; Handle setting WorkOffset Gcode

	if iWorkOffset_Method eq 0
		if iWorkOffsetmode eq 1
			if home_number <= 6
				nWorkoffset = 53 + mac_number
				nWorkoffset_f        			= '<G>2/2.0(p)< >'      ;Sets formatting output for workoffset 
			else
				;nWorkoffset = 103 + mac_number
				nWorkoffset = (mac_number - 6)
				nWorkoffset_f        			= '<G54.1P>2.0(p)< >'      ;Sets formatting output for workoffset 
			endif
		elseif iWorkOffsetmode eq 2 or iWorkOffsetmode eq 3
			nWorkoffset = mac_number
		endif
	else
		nWorkoffset = tonum(home_user_name)
	endif
    
	if bMco and MCO_CoordSysType eq 1
		nWorkoffset = nHomeOffset          
	endif
    
	if  iWorkOffsetmode eq 0
		change(nWorkOffset) = false
	endif

endp

@usr_HSM (logical bOn)
	if bOn and !bHSMActive
		{nb,'G05 P'iG05P}
		bHSMActive = true
	elseif !bOn and bHSMActive
		{nb,'G05 P0'}
		bHSMActive = false
	endif
endp

@usr_init_gmstates
	; Handle initializing G/M codes for correct modality from beginning of file
    
	iMotionMode             = 9999
	iAbsInc             = 9999
	iDiametercomp           = 40
	iDOffset        		= 9999
	iMplane                 = 9999      
	nPos<<1>>               = 9999
	nPos<<2>>               = 9999
	nPos<<3>>               = 9999
	nPos<<4>>               = 9999
	nPos<<5>>               = 9999
	nSpinType               = 9999
    
	sync_status_s           = 2

    
	; Handle initail state of parameters
	bFirstTC<<1>>       = true
	bFirstTC<<2>>       = true
	bFirstTC<<3>>       = true
	bFirstTC<<4>>       = true
	bManualTC           = false

	change(iDOffset) = false

	call @usr_coolant_off
	call @usr_coolant_reset
endp

@usr_MachinePlane(logical bOutput Logical bForce)
	local numeric rotb
	if job_machine_type eq turning
		iMplane = 18
	else
		if abs(nToolDirectionInStation<<ChannelID,2>>) eq 0 ;If tool is mounted in Z direction
			iMplane = 17
		else
			iMplane = 19
		endif
	endif
	if rot_axis_type eq axis4_face
		iMplane = 17
	endif
	if rot_axis_type eq axis4_radial
		iMplane = 18
	endif
	if instr(job_type,'drill') ne 0
		iMplane = 17 ; drill cycles must be in G18 plane 
	endif		
	if bForce
		change(iMplane) = true
	endif
	if bOutput
		if change(iMplane)
			{nb [iMplane]}
		endif
	endif
		
endp

@usr_MillingMode(logical bMillingOn logical bForce)
	local integer i j
	
	if bMillingOn eq true
		i = 1
	else
		i = 2
	endif

	j = spindle + 1

	
	nMillMode<<ChannelID>> = iMillModeOnOff<<j,i>>
	if bForce
		change(nMillMode<<ChannelID>>) = true
	endif
	if change(nMillMode<<ChannelID>>)
		{nb [nMillMode<<ChannelID>>:'<M>2/3.0(n)< >']}
		if i eq 1
			;{nb 'C0.0'}
		endif
	endif
endp

@usr_optionalstop
	; Handle line for Optional Stop G/M code 
	iStopmode = 1
	{nb, iStopmode:mcode_f}
endp 

@usr_outputUserMessages
	; Handle output of UserMessages(Message field in Operation)
	; Special routine below for multiple line messages
	local integer i poz1 l1b pr1
	local string msg1 msg1a msg1b
    
	if msg ne ''        
		i = 1
		while i < 50
			i = i + 1
			poz1=instr(msg,'\n')
			if poz1 eq 0
				poz1=strlen(msg)
				msg1=msg
			else
				poz1 = poz1-2
				msg1=left(msg,poz1)
			endif
			{nb, cCb,msg1,cCe}
			poz1=instr(msg,'\n')
			if poz1 eq 0
				i = 51
			else
				l1b=strlen(msg)-strlen(msg1)
				pr1=poz1+1
				msg1b=substr(msg,pr1,l1b)
				msg=msg1b
			endif
		endw
	endif
endp

@usr_prep_home_axis (string s)
	; Handle parsing of homing string and preping of output for homing
	local integer i line l mode p1 xMode
	local string  s1 s2 l1 pstr
	if s eq '' 
		return         
	endif                     
	s1 = s                                     ;Temp String
	l = strlen(s1)                             ;Get string length of Temp String
	s2 = substr(s1,1,1)                   ;*Check for 'x' in first character to flag separate iHomingmode for each line
	if s2 eq 'x'
		xMode = 1
		s1 = substr(s1,2,l)                        ;Remove 'x' from Temp String
		l = strlen(s1)                             ;Get string length of Temp String
	else
		xMode = 0
	endif
	if !xMode                                    ;*Pull out Homing mode (when not using xMode)
		p1 = instr(s1,':')                         ;Find the position of first ":"
		l1 = left(s1,p1-1)                         ;Pull out the left of first ":"
		mode = tonum(l1)                           ;Convert string into Integer for "Mode" variable
		s1 = substr(s1,p1+1,l)                     ;Remove Homing mode from Temp String
		l = strlen(s1)                             ;Get string length of Temp String
		;*Pull out Preperation String
		p1 = instr(s1,':')                         ;Find the position of second ":"
		if p1 ne 0                                 ;Check if PrepStr is defined
			pstr = left(s1,p1-1)                   ;Pull out the left of second ":"
			s1 = substr(s1,p1+1,l)                 ;Remove PrepString from Temp String
			l = strlen(s1)                         ;Get string length of Temp String
		endif
	endif                                         ;*Pull out homing lines and send to output procedure
	i = 1
	while i < 50
		i = i + 1
		if xMode                                     ;*Pull out Homing mode (when using xMode)
			p1 = instr(s1,':')                         ;Find the position of first ":"
			l1 = left(s1,p1-1)                         ;Pull out the left of first ":"
			mode = tonum(l1)                           ;Convert string into Integer for "Mode" variable
			s1 = substr(s1,p1+1,l)                     ;Remove Homing mode from Temp String
			l = strlen(s1)                             ;Get string length of Temp String
			;*Pull out Preperation String
			p1 = instr(s1,':')                         ;Find the position of second ":"
			if p1 ne 0                                 ;Check if PrepStr is defined
				pstr = left(s1,p1-1)                   ;Pull out the left of second ":"
				s1 = substr(s1,p1+1,l)                 ;Remove PrepString from Temp String
				l = strlen(s1)                         ;Get string length of Temp String
			endif
		endif
		p1 = instr(s1,';')                      ;Find the position of ";"
		if p1 ne 0
			line = line + 1                     ;Keep track of lines. Not Used!!
			l1 = left(s1,p1-1)                  ;Pull out the left of ";"
			iHomingmode = mode                  ;Send Homing Mode
			cHomep = pstr                       ;Send Preperation String
			sHomeline = l1                      ;Send Homing Line
			call @usr_home_axis
		else
			line = line + 1                     ;Keep track of lines. Not Used!!
			iHomingmode = mode                  ;Send Homing Mode
			cHomep = pstr                       ;Send Preperation String
			sHomeline = s1                      ;Send Homing Line
			call @usr_home_axis
			i = 50                              ;Force end of While-Loop
		endif
		if i ne 50
			s1 = substr(s1,p1+1,l)              ;Remove Homing mode from Temp String
			l = strlen(s1)                      ;Get string length of Temp String
		endif
	endw
endp

@usr_PrintErrorMsg(integer iMessage)
	local string sLanguage
	sLanguage = 'eng'
	if sLanguage eq 'eng'
		sErrorMsg<<1>>	= 'Please disable corner fillets on cut-off operation'
		sErrorMsg<<2>>	= 'Problem in tool number : '+tostr(tool_position_in_turret)+'! Tool Number must be same as Tool Station/Position number!'
		sErrorMsg<<3>>	= original_job_name+': Multi-start thread is not supported by G92 Cycle! Please turn off Use Cycle in order to use G32/G33/G34 Thread!'
		sErrorMsg<<4>>	= original_job_name+': Thread on Face or Back is not supported by G92 Cycle! Please turn off Use Cycle in order to use G32/G33/G34 Thread!'
		sErrorMsg<<5>>	= original_job_name+': Please activate option approximate arc by lines (Motion Control), polar coordiantes does not support arcs!'	
		sErrorMsg<<6>>	= 'Delta between two Wait Labels must be 10! Please use default settings!'
		sErrorMsg<<7>>	= original_job_name+': MCO is defined in wrong Channel! Please defined it in Channel $1.'
		sErrorMsg<<8>>	= original_job_name+': MCO is defined in wrong Channel! Please defined it in Channel $2.'
	elseif sLanguage eq 'de'
		;
	elseif sLanguage eq '' ;input your language
		;
	endif
	print sErrorMsg<<iMessage>>
	{nb 'M01 (GCODE ABORTED)'}
	{nb nb 'M30'}
	{nl'%'}
endp

@usr_PlaneRotation(logical bOnOff)

	if bOnOff and !bPlaneRotActive		
		if iPlaneOutputType eq 1		
			if iPlaneRotType eq 1 
				{nb'G68 ' shift_x:'<X>4.4< >' shift_y:'<Y>4.4< >' shift_z:'<Z>4.4< >' 'I0 J1 K0 R'(nPos<<5>>)}
			elseif iPlaneRotType eq 2
				;if nPos<<5>> lt 90 or nPos<<5>> eq 90
				;{nb'G68.2 P1 ' shift_x:'<X>4.4< >' shift_y:'<Y>4.4< >' shift_z: '<Z>4.4< >', rotate_angle_x:'<I>4.4< >', rotate_angle_y:'<J>4.4< >' rotate_angle_z:'<K>4.4< >' }
				;euler_angle_z:90.000 euler_angle_x:90.000 euler_angle_dev_z:-90.000

				;{nb,'euler_angle_dev_z=',euler_angle_dev_z} 

				;{nb,'euler_next_z=',(norm360(euler_next_z))}
				;{nb,'euler_next_x=',euler_next_x}
				;{nb,'euler_next_dev_z=',euler_next_dev_z}
	
				{nb'G68.2 ' shift_x:'<X>4.4< >' shift_y:'<Y>4.4< >' shift_z: '<Z>4.4< >', (norm360(euler_next_z)):'<I>4.4< >', euler_next_x:'<J>4.4< >',(euler_next_dev_z):'<K>4.4< >' }
				;if euler_angle_dev_z gt 0 ; fix to I if K is positive
				;if submachine_id eq 2
				;euler_angle_dev_z = (euler_angle_dev_z - 180)
				;endif
				;{nb'G68.2c ' shift_x:'<X>4.4< >' shift_y:'<Y>4.4< >' shift_z: '<Z>4.4< >', (180 + euler_angle_z):'<I>4.4< >', euler_next_x:'<J>4.4< >'}
				;if euler_angle_dev_z eq 0
				;{(euler_angle_dev_z):'<K>4.4< >' }
				;else
				;{(euler_angle_dev_z*-1):'<K>4.4< >' }
				;endif
				;else
				;if submachine_id eq 2
				;euler_angle_dev_z = (euler_angle_dev_z - 180)
				;endif
				;{nb'G68.2d ' shift_x:'<X>4.4< >' shift_y:'<Y>4.4< >' shift_z: '<Z>4.4< >', euler_angle_z:'<I>4.4< >', euler_next_x:'<J>4.4< >',euler_angle_dev_z:'<K>4.4< >' }
				;endif
				{nb,'M108'}
				{nb,'G53.1'}
				{nb,'M107'}
				
				;endif
				;if nPos<<5>> gt 90
				;{nb'G68.2 P1 ' shift_x:'<X>4.4< >' shift_y:'<Y>4.4< >' shift_z: '<Z>4.4< >', opposite_rotate_angle_x:'<I>4.4< >', nPos<<5>>:'<J>4.4< >' opposite_rotate_angle_z:'<K>4.4< >' }
				;endif
			elseif iPlaneRotType eq 3
				{nb'G68.2 P3 ' shift_x:'<X>4.4< >' shift_y:'<Y>4.4< >' shift_z '<Z>4.4< >' normal_to_plane_x:'<I>4.4< >', normal_to_plane_y:'<J>4.4< >' normal_to_plane_z:'<K>4.4< >'  }
			endif
		elseif iPlaneOutputType eq 2
			local Numeric X0 Y0 Z0 A B C Z
			local String FR TC ST MODE DIR FR_I P cycle_zero_f
			
			cycle_zero_f	= '5.6(p)'
			X0 = shift_x
			Y0 = shift_y
			Z0 = shift_z
			A = nPos<<5>>
			B = 0
			C = nPos<<4>>
			Z = 0
			FR = "0"
			TC = "\x22TC8\x22"
			ST = "100000"
			MODE = "192"
			DIR = "-1"
			FR_I = ""
			P = "1" ;

			{nb,'CYCLE800' '(' FR ',' TC ',' ST ',' MODE ',' X0:cycle_zero_f ',' Y0:cycle_zero_f ',' Z0:cycle_zero_f ',' A:cycle_zero_f ',' C:cycle_zero_f ',' Z:cycle_zero_f ',0,0,0,' DIR ',' FR_I ',' P ')'}

		elseif iPlaneOutputType eq 3
			change(nPos<<4>>) = true
			change(nPos<<5>>) = true
			{nl 'CYCLE DEF 19.0'}
			{nl 'CYCLE DEF 19.1 ' [nPos<<4>>] [nPos<<5>>] }
			{nl 'L A+Q120 C+Q122 R0 FMAX'}
		endif
		bPlaneRotActive = true	
	elseif !bOnOff and bPlaneRotActive
		if iPlaneOutputType eq 1
			{nb 'G69 '}
			;{nl}
		elseif iPlaneOutputType eq 2
			{nb 'CYCLE800()'}
		elseif iPlaneOutputType eq 3
			{nb 'CYCLE DEF 19.0'}
			{nb 'CYCLE DEF 19.1 '}		
		endif
		
		bPlaneRotActive = false
		
	endif


endp

@usr_ReplaceStrings
	sReplaced=replace(sReplaced,'','ae',0)
	sReplaced=replace(sReplaced,'','oe',0)
	sReplaced=replace(sReplaced,'','ue',0)
	sReplaced=replace(sReplaced,'','ae',0)
	sReplaced=replace(sReplaced,'','oe',0)
	sReplaced=replace(sReplaced,'','ue',0)
	sReplaced=replace(sReplaced,'','ss',0)
	sReplaced=replace(sReplaced,'','e',0)
	sReplaced=replace(sReplaced,'','a',0)
	sReplaced=replace(sReplaced,'','e',0)
	sReplaced=replace(sReplaced,'','e',0)
	sReplaced=replace(sReplaced,'','a',0)
	sReplaced=replace(sReplaced,'','a',0)
	sReplaced=replace(sReplaced,'','a',0)
	sReplaced=replace(sReplaced,'','e',0)
	sReplaced=replace(sReplaced,'','E',0)
	sReplaced=replace(sReplaced,'','D',0)
	sReplaced=replace(sReplaced,'{','-',0)
	sReplaced=replace(sReplaced,'}','-',0)
	sReplaced=replace(sReplaced,'$','-',0)
	sReplaced=replace(sReplaced,'%','-',0)
	sReplaced=replace(sReplaced,'','o',0)
	sReplaced=replace(sReplaced,'~','-',0)
	sReplaced=replace(sReplaced,'\\','_',0)
	sReplaced=replace(sReplaced,'|','I',0)
	sReplaced=replace(sReplaced,'','-',0)
	sReplaced=replace(sReplaced,'"','-',0)
	sReplaced=replace(sReplaced,'','2',0)
	sReplaced=replace(sReplaced,'','3',0)
endp

@usr_Rotary_Brake(logical b4th logical b5th)	

	if b4th eq true		
		iBrake<<iTableNumber>> = iRotaryBrakeOnOff<<iTableNumber,1>>
	else
		iBrake<<iTableNumber>> = iRotaryBrakeOnOff<<iTableNumber,2>>
	endif
	
	if b5th eq true		
		iBrake<<iTurretNumber>> = iRotaryBrakeOnOff<<iTurretNumber,1>>
	else
		iBrake<<iTurretNumber>> = iRotaryBrakeOnOff<<iTurretNumber,2>>
	endif

	if iJobType eq 1
		change(iBrake<<iTableNumber>>) = false 
	endif 
	
	if change(iBrake<<iTableNumber>>) eq true and iBrake<<iTableNumber>> ne 999
		{nb [iBrake<<iTableNumber>>:mcode_f]}
	endif
	
	if change(iBrake<<iTurretNumber>>) eq true and iBrake<<iTurretNumber>> ne 999
		{nb [iBrake<<iTurretNumber>>:mcode_f]}
	endif
endp

@usr_rpos_calc
	local numeric nR1postemp nR2postemp nPR1postemp nPR2postemp
	local integer iRpos

	if iJobType eq 1
		if machine_b_value ne nPrevPos<<5>>
			nPos<<5>> = machine_b_value
		endif
		change(nPos<<4>>) = false
	
	else
		if X5_job or instr(job_type,'mw_drill') ne 0 or (rot_axis_type ne axis4_none and b5XMove)
			nR1postemp = apos               ;Rotary from 4/5x Simulatenous
			nR2postemp = bpos               ;Rotary from 4/5x Simulatenous
		else
			nR1postemp = anext              ;Rotary from 4/5x Start of Job
			nR2postemp = bnext              ;Rotary from 4/5x Start of Job
		endif
	
	
		if rot_axis_coord eq axis4_cartesian and rot_axis_type ne axis4_none
			iRpos = iRposControl<<2>>
		else
			iRpos = iRposControl<<1>>
		endif

		if bMco
			if userDef_a
				nPos<<4>> = move_axis_a
			endif
			if userDef_b
				nPos<<5>> = move_axis_b
			endif 
		elseif iRpos eq 0
			nPos<<4>> = nR1postemp
			nPos<<5>> = nR2postemp
		elseif iRpos eq 1
			nPos<<4>> = norm360(nR1postemp)
			nPos<<5>> = norm360(nR2postemp)
		elseif iRpos eq 2
			nPos<<4>> = norm360(nR1postemp) * -1
			nPos<<5>> = norm360(nR2postemp) * -1
		elseif iRpos eq 3
			nPos<<4>> = norm360(nR1postemp)
			nPos<<4>> = norm360(nR2postemp)
			if nR1postemp < nPR1postemp
				nPos<<4>> = norm360(nR1postemp) * -1
			endif
			if nR2postemp < nPR2postemp
				nPos<<5>> = norm360(nR2postemp) * -1
			endif
			if norm360(nR1postemp) ne norm360(nPR1postemp)
				change(nPos<<4>>) = TRUE
			else
				change(nPos<<4>>) = false
			endif
			if norm360(nR2postemp) ne norm360(nPR2postemp)
				change(nPos<<5>>) = TRUE
			else
				change(nPos<<5>>) = false
			endif
		elseif iRpos eq 4
			nPos<<4>> = first_axis_angle
			nPos<<5>> = second_axis_angle
		endif 
		
		
		if iRpos eq -1
			change(nPos<<4>>) = false
			change(nPos<<5>>) = false  
		else
			if ((!b1stRotary<<iTurretNumber>> or iJobType eq 1) and !bMco) or bInCartesian
				change(nPos<<4>>) = false
			endif		
			if (!b2ndRotary<<iTurretNumber>>) and !bMco
				change(nPos<<5>>) = false
			endif
		endif
	endif


endp

@usr_Set_nPrevPos 
       
	nPrevPos<<1>> = nPos<<1>>
	nPrevPos<<2>> = nPos<<2>>
	nPrevPos<<3>> = nPos<<3>> 
	nPrevPos<<4>> = nPos<<4>> 
	nPrevPos<<5>> = nPos<<5>>
    
endp

@usr_setfeed    
	; Set correct output feed for each cutting mode

	local numeric da dxh dyh dzh rad al
	dxh = abs(xhpos-oxh)
	dyh = abs(yhpos-oyh)
	dzh = abs(zhpos-ozh)
	da = ang(xhpos,yhpos) - ang(oxh,oyh)
	al = (dist(xhpos,yhpos)*dapos) / 57.2958
	rad = dist(xhpos,yhpos)

	if rot_axis_type ne axis4_none or X5_job
		;1. Multax cutting
		if iRotaryFeedType eq 1
			nFeed = feed ;!@#$%AC I think feed is output as deg/min now????
		endif 
		if iRotaryFeedType eq 2
			nFeed = feed
		endif
		if iRotaryFeedType eq 3
			if original_feed eq 0
				original_feed = feed
			endif
			if change(nPos<<4>>)
				if iDPMCalcMethod eq 1
					nFeed = abs(da) / ( dist(dxh,dist(dyh,dzh)) / original_feed )
				else
					if abs(al) gt 0.0001	
						nFeed = abs(dapos) * original_feed / ( dist(al,dzh))
					else
						nFeed = nFeed
					endif
				endif

				change(nFeed) = True
            
				if nFeed gt 6000
					nFeed = 6000
				endif
				if nFeed eq 0
					nFeed = original_feed
				endif
			else
				nFeed = original_feed
			endif
		endif
		if iRotaryFeedType eq 4
			nFeed = inverse_feed
			change(nFeed) = true
		endif
	else
		nFeed = feed
	endif
	if bMco
		nFeed = feed_move
	endif

	oxh = xhpos
	oyh = yhpos
	ozh = zhpos
    
endp

@usr_sof_character
	; Handle start of file character
    
	{cPb}
    
endp

@usr_sof_progname
	; Handle Program Number and/or Name  
	if ChannelID gt 1
		program_number = program_number + ChannelID - 1
	endif 
	if iSplit_ProgName_Num and bUseprognum and bUseprogname
		if iSplit_ProgName_Num == 1
			{nl, cCb, part_name,cCe} 
			{nl, cPn, program_number}
		else
			{nl, cPn, program_number}                
			{nl, cCb, part_name,cCe} 
		endif
	else
		if bUseprognum
			{nl, cPn,program_number}
			if bUseprogname
				{' 'cCb, part_name,cCe}
			endif
		else
			if bUseprogname
				{nl, cCb, part_name,cCe}
			endif
		endif    
	endif
	if bUseFileName
		{nl, cCb, g_file_name,cCe}
	endif    
    
endp

@usr_spindle_selection(logical bOutput logical bForce)
	
	nActiveSpindle = nSpindleCode<<iTableNumber>>
	
	;if bForce
	change(nActiveSpindle) = true
	;endif
	if bOutput
		;if change(nActiveSpindle)
		{nb,[nActiveSpindle]}
		;endif
	endif	


endp

@usr_SpindleDir_SpinFormat(logical bOnOff integer iJobType logical bOutput integer iTableNum integer iTurretNum )
	local integer iDirection
	local string  sIndex

	if bOnOff 
		if spin_direction eq CW 
			iDirection = 1
		elseif spin_direction eq CCW 
			iDirection = 2
		endif
	else
		iDirection = 3
	endif

	if iTableNum ne 0 and iTurretNum ne 0 
		if iJobType eq 1
			nSpindleDir = iDircode<<iTableNum,iDirection>>
			sIndex = sSpinIndex<<iTableNum>>
			;{nl'iTableNum='iTableNum}
			;{nl'drive_unit_gear_ID='drive_unit_gear_ID}
			nGear<<ChannelID>> =  nGearCode<<iTableNum,drive_unit_gear_ID>> 		
		else
			nSpindleDir = iDircode<<iTurretNum,iDirection>>
			sIndex = sSpinIndex<<iTurretNum>>	
			nGear<<ChannelID>> =  nGearCode<<iTurretNum,drive_unit_gear_ID>> 
		endif
	endif
	
	if nGear<<ChannelID>> eq 999 or nGear<<ChannelID>> eq 0
		change(nGear<<ChannelID>>) = false
	endif
	
	nSpin_f = '<S>5.0(p)<'+ sIndex +' >'
	nSpin = spin
	if bOutput
		if change(nSpindleDir)
			{nb,[nSpindleDir:mcode_f]}
		endif
	endif
endp

@usr_sync_process
	iMCOSyncLabel<<ChannelID>> = iMCOSyncLabel<<ChannelID>> + 1
	{nb iMCOSyncLabel<<ChannelID>>:sync_label_f}	
endp

@usr_TCP (logical bOn)
	if bOn and !bTCPActive 
		{nb,'G43.4 H',nOffset}
		;{nb,'G43.4' }
		skipline = false
		bTCPActive = true
	elseif !bOn and bTCPActive 	
		{nb,'G49'}
		bTCPActive = false
	endif
endp
  
@usr_US_date
	; Converts Europe Date format to US format
	Local Integer iInt1
	iInt1 = instr(date,'-')
	sUS_date = substr(date,(iInt1+1),3) + '-' + substr(date,1,(iInt1-1)) + '-' + right(date,4) 
endp

@usr_US_time
	; Converts Military time to 12hr format
	Local Integer iInt1 iHr_Mil_int iHour
	Local String iHr_Mil iTm_of_day
	iInt1 = instr(time,':')
	iHr_Mil = left(time,(iInt1-1))
	iHr_Mil_int = tonum(iHr_Mil)
	if iHr_Mil_int < 12
		if iHr_Mil_int < 1
			iHour = 12
		else
			iHour = iHr_Mil_int
		endif
		iTm_of_day = 'AM'
	else
		if iHr_Mil_int < 13
			iHour = 12
		else
			iHour = iHr_Mil_int - 12
		endif
		iTm_of_day = 'PM'
	endif
	sUS_time = tostr(iHour:'5.0(p)') + substr(time,iInt1,8) + iTm_of_day
endp

;#endregion

;#region 07-Cycles

@act
	if ActionName eq 'Part Catcher'
		if move_act eq 1           
			{nb,'M06 (Parts Catcher Advance)'}           
		elseif move_act eq 2 
			{nb,'M07(Parts Catcher Retract)'}
		endif 
	endif
    
	if ActionName eq 'Tail Stock'
		if move_act eq 1           
			{nb,'M16 (Tail Stock Advance)'}           
		elseif move_act eq 2 
			{nb,'M17(Tail Stock Retract)'}
		endif 
	endif

endp

@act_air
	if air_blast_coolant eq 1
		iCoolantM<<13>> = iCoolantON<<13>>
	elseif air_blast_coolant eq 0 or air_blast_coolant eq 2
		iCoolantM<<13>> = iCoolantOFF<<13>>
	endif
	if MCO_New_Line
		{nb,[iCoolantM<<13>>:mcode_f]}
	endif   
endp

@active_air_through_spindle
	if air_blast_coolant eq 1
		iCoolantM<<13>> = iCoolantON<<13>>
	elseif air_blast_coolant eq 0 or air_blast_coolant eq 2
		iCoolantM<<13>> = iCoolantOFF<<13>>
	endif
	if MCO_New_Line
		{nb,[iCoolantM<<13>>:mcode_f]}
	endif   
endp

@cool_flood
	if flood_coolant eq 1
		iCoolantM<<1>> = iCoolantON<<1>>
	elseif flood_coolant eq 0 or flood_coolant eq 2
		iCoolantM<<1>> = iCoolantOFF<<1>>
	endif
	if MCO_New_Line
        
		{nb,[iCoolantM<<1>>:mcode_f]} 
              
	endif   
endp

@cool_mist
	if mist_coolant eq 1
		iCoolantM<<5>> = iCoolantON<<5>>
	elseif mist_coolant eq 0 or mist_coolant eq 2
		iCoolantM<<5>> = iCoolantOFF<<5>>
	endif
	if MCO_New_Line
		{nb,[iCoolantM<<5>>:mcode_f]}
	endif   
endp

@cool_through_tool

	if through_coolant eq 1
		iCoolantM<<9>> = iCoolantON<<9>>
	elseif through_coolant eq 0 or through_coolant eq 2
		iCoolantM<<9>> = iCoolantOFF<<9>>
	endif
	if MCO_New_Line 
		{nb,[iCoolantM<<9>>:mcode_f]}
	endif   
endp


@drill
	if job_machine_type eq milling
		call @rapid_move
	endif
	
	if job_machine_type eq milling
		if feed_status eq st_inch_teeth
			{nb,'G95'}
			feed = feed_teeth
		endif
		if feed_status eq st_inch_min 
			;{nb,'G94'}
		endif
	endif

	if job_machine_type eq turning
		if feed_unit eq mm_rev
			{nb,'G95'}
		endif
		if feed_unit eq mm_min
			{nb,'G94'}
		endif
	endif

	

	if spindle_direction_x eq 1 or spindle_direction_x eq -1 or spindle_direction_y eq 1 or spindle_direction_y eq -1 and !bPlaneRotActive
		if drill_type eq Peck ; these are the same as below because of G68.2 being active
			iDrillMode = 83			
		endif
		if drill_type eq Tapping
			;{nb 'M29 'spin}
			iDrillMode = 84
		endif
		if drill_type eq Boring
			iDrillMode = 83
		endif	
	else
		if drill_type eq Peck
			iDrillMode = 83
		endif
		if drill_type eq Tapping
			;{nb 'M29 'spin}
			iDrillMode = 84
		endif
		if drill_type eq Boring
			iDrillMode = 83
		endif		
	endif
	if  drill_type eq Peck and down_step eq 0
		iDrillMode = 82
	endif
	
	if rot_axis_type eq axis4_radial or bnext eq 90 or spindle_direction_x eq 1 or spindle_direction_x eq -1 or spindle_direction_y eq 1 or spindle_direction_y eq -1
		if spindle_direction_x eq 1 or spindle_direction_x eq -1
			;{nb iDrillMode:gcode_f (drill_lower_zl):nPos_f<<1>>}
			{nb iDrillMode:gcode_f }
			if b_useRm
				{'G99 '}
			else
				{'G98 '}
			endif
			{(drill_lower_zl):nPos_f<<3>>}
		elseif spindle_direction_y eq 1 or spindle_direction_y eq -1
			;{nb iDrillMode:gcode_f (drill_lower_zl):nPos_f<<2>>}
			{nb iDrillMode:gcode_f }
			if b_useRm
				{'G99 '}
			else
				{'G98 '}
			endif
			{(drill_lower_zl):nPos_f<<3>>}
		endif
	elseif rot_axis_type eq axis4_face or spindle_direction_z eq 1 or spindle_direction_z eq -1
		if submachine_ID eq 1
			{nb iDrillMode:gcode_f  }
			if b_useRm
				{'G99 '}
			else
				{'G98 '}
			endif
			;{(drill_lower_zo):nPos_f<<3>>}
			{(drill_lower_z):nPos_f<<3>>}
		else
			{nb iDrillMode:gcode_f }
			if b_useRm
				{'G99 '}
			else
				{'G98 '}
			endif
			{(drill_lower_zo*-1):nPos_f<<3>>}
		endif
	elseif rot_axis_type eq axis4_none 
		if submachine_ID eq 1
			{nb iDrillMode:gcode_f  }
			if b_useRm
				{'G99 '}
			else
				{'G98 '}
			endif
			;{(drill_lower_zo):nPos_f<<3>>}
			{(drill_lower_z):nPos_f<<3>>}
		else
			{nb iDrillMode:gcode_f }
			if b_useRm
				{'G99 '}
			else
				{'G98 '}
			endif
			{drill_lower_z:nPos_f<<3>>}
		endif
	endif
	{drill_upper_zl:'<R>5.'+sSystem+'()< >'}
	if drill_type eq Peck or drill_type eq Tapping
		if down_step gt 0
			;{'Q'down_step:'5.'+sSystem+'/'+sSystem+'(n)< >'}
			{down_step:'<Q>5.'+sSystem+'()< >'}
		endif
	endif
	if Delay ne 0
		{Delay:'<P>5.'+sSystem+'/'+sSystem+'(n)< >'}
	endif
	if drill_type eq Tapping
		{tool_drill_lead:nFeed_f}
	else
		{feed:nFeed_f}
	endif
endp

@drill_point
	if first_drill eq false		
		call @rapid_move
		if rot_axis_type ne axis4_none
			{[apos:nPos_f<<4>>]}
		endif
		;if drill_type eq Peck
		;if down_step gt 0
		;{' Q'down_step:'5.'+sSystem+'/'+sSystem+'(n)< >'}
		;endif
		;endif
	endif
    
endp

@dwell
    
	{nb,'G04 P',dwell_time, ' '}
    
endp

@end_drill
	iMotionMode = 80
	{nl [iMotionMode]}
	if feed eq feed_teeth and job_machine_type eq milling
		{nb,'G94'}
	endif
endp

@end_mach_ctrl
	bMco = false
endp

@mco_cycle

	;if MCO_CycleName eq 'Part_Pull'
	;{nb,'G90 '}
	;{nb,'M302 (Sub Milling Mode Off) '}
	;{nb,'M200 (Main Milling Mode On)'}
	;{nb,'M300 (Sub Milling Mode On)'}
	;{nb,'M306 (Open Sub Chuck)  '}
	;{nb,'G00 W' pt_r_g53}
	;{nb,'G01 G53 W' pt_f_G53 , ' F' pt_f_feedrate}
	;{nb,'M307 (Close Sub Chuck)'}
	;{nb,'M206 (Open Main Chuck)'}
	;{nb,'G01 G53 W' pp_G53z , 'F' pp_feed}
	;{nb,'M207 (Close Main Chuck)'}
	;{nb,'M306 (Open Sub Chuck)  '}
	;{nb,'M202 (Main Milling Mode Off) '}
	;{nb,'M302 (Sub Spindle Turning Mode)'}
	;{nb,'G00 G53 W0 (Return W home)'}
	;endif

	;if MCO_CycleName eq 'Sub_Approach_Hold'
	;{nb,'G90 '}
	;{nb,'M902 (Sub) '}
	;{nb,'M302 (Sub Milling Mode Off) '}
	;{nb,'M200 (Main Milling Mode On)'}
	;{nb,'M300 (Sub Milling Mode On)'}
	;{nb,'M306 (Open Sub Chuck)  '}
	;{nb,'G54'}
	;{nb,'G00 W' pt_r_g53}
	;{nb,'G94'}
	;{nb,'G01 W' pt_f_G53 , ' F' pt_f_feedrate}
	;{nb,'M307 (Close Sub Chuck)'}
	;{nb,'G95'}
	;endif

	if MCO_CycleName eq 'Stock_Position_MCO'
		; sp_z : 0.500  sp_z_feed : 20.000
		{nb '(BLOCK SKIP 5 ON = SKIP BAR FEEDER)'}
		{nb '(BLOCK SKIP 3 ON = NON STOP CYCLE)'}
		{nb ''}
		{nb '/3 M00'}
		{nb ''}
		{nb 'M648'}
		{nb ''}
		{nb 'G90'}
		{nb 'G00 G53 W0.0'}
		{nb 'G53 X0.0'}
		{nb 'G53 Y0.0'}
		{nb 'G53 Z0.0'}
		{nb ''}
		{nb '/5 GOTO1234 (SKIP 5 ON = SKIP BAR FEED)'}
		{nb 'GOTO1235'}
		{nb ''}
		{nb 'N1234'}
		{nb '(STOCK POSITION)'}
		{nb 'G69'}
		{nb 'G0 G00 G20 G40 G80 G90 G95 G98'}
		{nb 'G17'}
		{nb 'G97'}
		{nb 'T60.1 T2 M6'}
		{nb 'G69'}
		{nb 'G10.9 X0'}
		{nb 'M648'}
		{nb 'M901'}
		{nb 'M200'}
		{nb 'G0G90'}
		{nb ''}
		call @usr_home_number
		{nb nWorkoffset}
		{nb 'G68.2 X0. Y0. Z0. I90. J90. K-90.'}
		{nb 'G53.1'}
		{nb 'G0Z2.0 X-0.425 Y0.0'}
		{nb 'G94'}
		{nb 'G1Z',sp_z'F',sp_z_feed}
		{nb 'G69'}
		{nb 'M01'}
		{nb ''}
		{nb 'M206 (CHUCK OPEN)'}
		{nb 'M768 (BAR FEED)'}
		{nb 'M207 (CHUCK CLOSE)'}
		{nb ''}
		{nb 'M01'}
		{nb ''}
		{nb 'N1235'}
	endif

	;if MCO_CycleName eq 'Sub_Retract_Home'
	;{nb,'M306 (Open Sub Chuck)  '}
	;{nb,'M202 (Main Milling Mode Off) '}
	;{nb,'M302 (Sub Spindle Turning Mode)'}
	;{nb,'G00 G55 W0 (Return W home)'}
	;endif

	if MCO_CycleName eq 'Transfer_M2S' 
		;..> m2s_W : 2.000  m2s_feed_w : -0.750  m2s_feed : 20.000

		{nb '(TRANSFER)'}
		{nb 'G0 G90'}
		{nb 'G0 G53 X0.0'}
		{nb 'G0 G53 Z0.0'}
		{nb 'G0 G53 B0.0'}
		{nb 'M200 (MAIN SPINDLE MILLING)'}
		{nb 'G0 C0. (ORIENT MAIN)'}
		{nb 'M300 (SUB SPINDLE MILLING)'}
		{nb 'G0 U0. (ORIENT SUB)'}
		{nb 'M306 (OPEN SUB CHUCK)'}
		{nb 'M540 (TRANSFER MODE ON)'}
		call @usr_home_number
		{nb nWorkoffset}
		{nb 'G00 W',m2s_W}
		{nb 'G94'}
		{nb 'G01 W',m2s_feed_w,' F',m2s_feed}
		{nb 'M307 (CLOSE SUB CHUCK)'}
		{nb 'M206 (OPEN MAIN)'}
		{nb 'G0 G53 W0.0'}
		{nb 'M541 (TRANSFER MODE OFF)'}
		{nb 'M01'}
	endif

	if MCO_CycleName eq 'Part_Unload' 
		;..> UA_A : -3.950  UA_U : -26.000  UA_C : 2.400  UA_D : 1.000
		{nb 'M09 '}
		if prev_job_mac_type eq turning
			if submachine_ID eq 1
				{nb 'M205 '}
			else
				{nb 'M305 '}
			endif
		else
			{nb 'M05 '}
		endif
		{nb 'G28 G91 G00 X0.'}
		{nb 'G28 G91 G00 Y0.'}
		{nb 'G28 G91 G00 Z0.'}
		{nb 'G90'}
		{nb,'M01'}
		{nb,'(UNLOADER)'}
		{nb 'G0 G53 W0.0 B90.0'}
		{nb,'G900 A',UA_A,' B',UA_U,' C',UA_C,' D',UA_D}
	endif 

	if MCO_CycleName eq 'CLOSE_MAIN_CHUCK'
		{nb 'M207 (MAIN CHUCK CLOSE)'}
	endif

	if MCO_CycleName eq 'ROTARACK'
		{nb 'M400 (ROTARACK)'}
		{nb 'M400 (ROTARACK)'}
		{nb 'M400 (ROTARACK)'}
	endif
endp

@min_quan_loubr

	minimum_quantity_L_val = min_quan_lubr_val
endp

@move_object


endp

@open_close_obj
  
	if ActionName eq 'Main Chuck'
		if open_close eq 1   
			{nb,'M69 (Unclamp Main Chuck)'}                      
		elseif open_close eq 2 
			{nb,'M68 (Clamp Main Chuck)'} 
		endif 
	endif
    
	if ActionName eq 'Sub Chuck'
		if open_close eq 1   
			{nb,'M169 (Unclamp Sub Chuck)'}                      
		elseif open_close eq 2 
			{nb,'M168 (Clamp Sub Chuck)'} 
		endif 
	endif
endp

@spin

endp

@start_mach_ctrl


endp

@start_obj_act
    
endp

@thread    
	local integer iAddNumberStartCounter
	local numeric nThreadTapper nMultiStartAngle nXstart nThreadXstart nThreadStepDown
	

	
	if process_type eq face or is_line eq false
		call @usr_PrintErrorMsg((4))
	endif
	
	if inch_system
		if lead_unit <> mm
			lead = (1/lead) ;lead calculation changed in SC2020
		else
		
			lead = (lead/25.4)
		endif
	else
		if lead_unit <> mm
			lead = (1/(lead/25.4)) 
		else
			lead = (lead)
		endif
	endif
	
	if !bG76Cycle or work_type eq 0
		nXstart = xopos
		nThreadTapper = first_pos_x-last_pos_x
		if nThreadTapper ne 0
			change(nThreadTapper)=true
		endif

		if turning_mode eq external ; internal/front/back)
			nXstart = (last_pos_x+depth+safety)
			nThreadXstart = (first_pos_x+depth-down_step)
			if xopos < nXstart
				iMotionMode = 0
				{nb iMotionMode nXstart:nPos_f<<1>>}
			else
				nXstart = xopos
			endif
		endif
		if turning_mode eq internal
			nXstart = (last_pos_x-depth-safety)
			nThreadXstart = (first_pos_x-depth+down_step)
			if xopos > nXstart
				iMotionMode = 0
				{nb iMotionMode nXstart:nPos_f<<1>>}
			else
				nXstart = xopos
			endif
		endif
	
		iMotionMode = 292
	
		if work_type eq 1	
			if multi_start_type ne 0 and type_starts eq 0
				call @usr_PrintErrorMsg((3))
			endif
			{nb iMotionMode nThreadXstart:nPos_f<<1>> last_pos_z:nPos_f<<3>> ['R'nThreadTapper] lead:nFeed_f} 
			if turning_mode eq external
				nThreadStepDown = nThreadXstart - down_step
				while nThreadStepDown gt (min_diameter/2)
					{nb nThreadStepDown:nPos_f<<1>>}
					nThreadStepDown = nThreadStepDown - down_step
				endw
				if nThreadStepDown ne (min_diameter/2) 
					nThreadStepDown = min_diameter + minimum_step_down
					{nb (min_diameter/2):nPos_f<<1>>}
				endif
			elseif turning_mode eq internal
				nThreadStepDown = nThreadXstart + down_step
				while nThreadStepDown lt (min_diameter/2)
					{nb nThreadStepDown:nPos_f<<1>>}
					nThreadStepDown = nThreadStepDown + down_step
				endw
				if nThreadStepDown ne (min_diameter/2) 
					nThreadStepDown = min_diameter - minimum_step_down
					{nb (min_diameter/2):nPos_f<<1>>}
				endif
			endif
		endif
		if work_type eq 0
			{nb iMotionMode nThreadXstart:nPos_f<<1>> last_pos_z:nPos_f<<3>> ['R'nThreadTapper] lead:nFeed_f}
		endif
	
	else  ; G76 Cycle
	
		local numeric nthread_dev_angle taper nMultiDistance d
		local integer i a 
		local numeric nG76P3 nG76P4 nG76Q1 nG76R1 
		local numeric nG76X nG76Z nG76P4 nG76Q2 nG76R2 nG76F
		local string nG76P1_f nG76P2_f nG76P3_f nG76Q1_f nG76Q2_f 
		local string nG76R1_f nG76P4_f nG76X_f	nG76Z_f	nG76R2_f nG76F_f

		nG76X_f							= '<X>5.'+sSystem+'(*'+sDouble+')< >'
		nG76Z_f							= '<Z>5.'+sSystem+'< >'
		nG76R2_f						= '<X>5.'+sSystem+'< >'
		nG76F_f							= '<F>5.'+sSystem+'< >'
		
		nG76P1_f                        = '<P>z2.0(n)<>'
		nG76P2_f                        = '<>z2.0(n)<>'
		nG76P3_f                        = '<>z2.0(n)< >'
		nG76Q1_f                        = '<R>5.'+sSystem+'< >'
		nG76Q2_f                        = '<Q>5.'+sSystem+'< >'
		nG76R1_f                        = '<R>0.4z(n)< >'
		nG76P4_f                        = '<P>5.'+sSystem+'< >'

		iMotionMode = 276
		
		taper = (first_pos_x - last_pos_x)
		nG76R2 = taper
		nG76X = last_pos_x
		nG76Z = last_pos_z
		nG76P4 = depth   
		nG76P3 = tool_ALFA
		nG76Q1 = down_step
		nG76Q2 = minimum_step_down
		nG76F = lead
		if multi_start_type eq true and type_starts eq 0
			nthread_dev_angle = 360 / number_of_starts
			i = number_of_starts
		else
			i = 1
		endif
		
		a = 1
		nMultiDistance = lead / number_of_starts
		
		if taper eq 0			
			change(nG76R2) = false
		else
			change(nG76R2) = true
		endif        
		if nG76R1 eq 0
			change(nG76R1) = false
		else
			change(nG76R1) = true
		endif 
		
		while i gt 0 
			{nb,iMotionMode, nG76P1, nG76P2, nG76P3, nG76Q1}
			{nb,iMotionMode, nG76X, nG76Z, nG76P4,  nG76Q2, nG76F }            
		
			i = i - 1
		
			if a gt 0 
				d = nMultiDistance 
				if spindle eq 0
					nPos<<3>> = nPos<<3>> + d
				elseif spindle eq 1
					nPos<<3>> = nPos<<3>> - d
				endif
			endif

			if i gt 0
				iMotionMode = 0
				{nb,[iMotionMode], nPos<<1>>}
				{nb,[iMotionMode], nPos<<3>>}
			endif
			a = a + 1
		endw
	endif

endp

@turn_drill
	drill_lower_zo=drill_lower_z
	drill_upper_zo=drill_upper_z
	drill_upper_zl= drill_upper_z + safety
	call @drill
	call @end_drill
endp

@turn_endproc
	blknum_gen = false
	blknum_exist = false
endp

@turn_proc
	blknum_exist = true
	blknum_gen = true
endp

@turn_thread_line

	call @usr_control_pos_set (('line'))
	call @usr_setfeed
	
	change(nFeed) = true
	
	iMotionMode = 32
	change(iMotionMode) = true	
	{nb, [nFeedType], [iMotionMode], [nPos<<1>>], [nPos<<3>>], [nFeed]}
endp
;-------------------
@turn_thread_arc
	
	call @usr_control_pos_set (('arc'))
	call @usr_setfeed
	
	change(nFeed) = true	
	iMotionMode = 32	
	change(iMotionMode) = true	
	{nb, [nFeedType], [iMotionMode], [nPos<<1>>], [nPos<<2>>], [nPos<<3>>], [nPosArc<<4>>], [nPosArc<<1>>], [nPosArc<<2>>], [nPosArc<<3>>], [nFeed]}
endp
;-------

@turning 

	if work_type eq rough
		if process_type eq long
			{nb 'G271 U'down_step ' R'retreat_distance}
			{nb 'G271 P'start_line ' Q'end_line ' U' rough_offset_x ' W' rough_offset_z' '  feed:nFeed_f}
		else    
			{nb 'G272 W'down_step ' R'retreat_distance}
			{nb 'G272 P'start_line ' Q'end_line ' U' rough_offset_x ' W' rough_offset_z' '  feed:nFeed_f}
		endif
	endif
	if work_type eq copy
		{nb 'G73 U'(retreat_distance*2),' W'retreat_distance}
		{nb 'G73 P'start_line ' Q'end_line ' U' rough_offset_x ' W' rough_offset_z' ' feed:nFeed_f}
	endif
	if work_type eq profile
		{nb 'G270 P'start_line ' Q'end_line feed:nFeed_f}
	endif

endp

@working_mode

endp

@tool_breakage
	if !b_tclear
		call @usr_coolant_off
		call @usr_coolant_output
		call @usr_SpindleDir_SpinFormat((0),(job_machine_type),(1),(iTableNumber),(iTurretNumber))
		call @usr_prep_home_axis ((sHomestrtc<<ChannelID>>))
	else
		b_tclear = false
	endif
	{nb, tool_number:'<T>3/3.0(p)<.>' nOffset:'<>2/2.0(p)< >'' (SPINDLE TOOL) M6'}
	{nb 'M283 (MSR UNIT ON)'}
	{nb 'G0G90'}
	{nb 'G54.1P300 B0.'}
	;{nb,'nToolLengthH=',nToolLengthH}
	;{nb, tool_number:'<G43H>3/3.0(p)<.>' nOffset:'<>2/2.0(p)< Z1.>'}
	{nb, tool_number:'<G43H>3/3.0(p)<.>' nToolLengthH:'<>2/2.0(p)< Z1.>'}
	{nb 'G136 B0. M1. J',tolerance_len,' Q52.'}
	{nb 'M284 (MSR UNIT OFF)'}
	{nb,nWorkoffset}
	{nb 'G28 G91 G00 X0.'}
	{nb 'G28 G91 G00 Y0.'}
	{nb 'G28 G91 G00 Z0.'}
	{nb 'G90'}
endp


;#endregion


